Define layered chess scenarios
No tasks in progress


# 1) Conceptual model: separate “rules”, “laws”, “domain”, “objective”, “preferences”

Your simplified version probably has:

* Position (relative coords, black king at origin)
* chess movegen & legality
* trap solver, tempo solver, mate checks

To add scenario restrictions cleanly, insist on **four layers**:

## A. Rules (pure chess)

“Traditional pieces move like chess, collisions, king cannot move into check, captures happen.”

* No scenario-specific constraints here.
* Uses bound only for *state enumeration* (if you enumerate), not for move legality.

## B. Laws (scenario-specific legality restrictions)

These modify what counts as a legal move (like Python’s CORNER_MODE or “disallow captures”, “white king may not cross line”, etc.).

> Laws are applied *after* core movegen but *before* the solver sees the move set.

Examples:

* “Black king can’t go below y = 0” (corner clamp)
* “White cannot capture”
* “White cannot move bishops off the rim squares”
* “White may pass only when in a passable subset”

## C. Domain (“inside the modeled slice / candidate set”)

This is not legality. This is the set your solver tries to remain within.

* Trap solver uses: black wants to force play outside the domain; white wants to keep inside.
* **Leaving the domain is allowed**, but it counts as escape if the opponent can force it.

This matches the pruning philosophy: black “escapes” only if after a black move, **all** white replies fail to return/stay inside.

## D. Objective

What you compute:

* Trap (safety)
* TempoTrap (Büchi objective: visit passable positions infinitely often)
* Mate / “mate-in-k” / retrograde wins

Objectives consume the same Rules + Laws + Domain.

## E. Preferences (non-adversarial “tie-breakers”)

These do **not** change correctness when you compute worst-case traps/wins.
They help with:

* “best black escape attempt” for demos,
* “which white reply to pick” for playing vs trap,
* “which position to print”.

Examples:

* prefer black move maximizing distance from nearest white piece
* prefer capture if legal
* prefer white reply that increases “tempo slack”

---

# 2) Minimal but extensible API shape

## 2.1 Scenario must specify a starting setup

Make it impossible to run anything without it.

Recommended:

rust
pub struct Scenario {
    pub name: &'static str,
    pub bound: i16,              // L∞ enumeration bound
    pub move_bound: u8,          // slider travel cap
    pub white_can_pass: bool,    // base ability
    pub start: StartState,       // REQUIRED
    pub laws: Laws,
    pub domain: Domain,
    pub preferences: Preferences,
    pub limits: ResourceLimits,
}

pub struct StartState {
    pub to_move: Side,           // Side::Black or Side::White
    pub position: Position,      // relative coords (black king at origin)
}


**Important**: require tests that start is:

* within bound (if you’re enumerating),
* legal under rules,
* satisfies domain predicate if the objective expects it.

## 2.2 Laws, Domain, Preferences should be “composable”

Keep it simple. Don’t rebuild a giant abstraction framework.

A good approach:

* Laws is a bundle of optional filters:

  * state_filter: fn(&Position)->bool (optional)
  * black_move_filter: fn(&Position,&Position)->bool (from,to)
  * white_move_filter: fn(&Position,&Position)->bool
  * pass_allowed: fn(&Position)->bool (optional; if absent, pass uses white_can_pass)

* Domain is a simple membership check:

  * inside: fn(&Position)->bool

* Preferences is a couple of orderings:

  * rank_black_moves: fn(&Position,&[Position])->Vec<usize> or comparator
  * rank_white_moves: fn(&Position,&[Position])->Vec<usize>

### Performance note

To avoid dynamic dispatch overhead inside tight loops:

* represent these as **structs with #[inline] methods** and pass them generically into solvers:

rust
pub trait DomainLike { fn inside(&self, p: &Position) -> bool; }
pub trait LawsLike { /* filters */ }
pub trait PreferencesLike { /* ranking */ }


Then:

rust
pub fn compute_trap<D: DomainLike, L: LawsLike>(..., domain: &D, laws: &L, ...) -> ...


This keeps everything monomorphized and fast.

---

# 3) Where to enforce bounds and restrictions

### The big rule

**Never let the solver assume the slice boundary is a wall.**

Instead:

* Slice (bound) constrains **enumeration / candidate set building**
* Laws constrain **move legality**
* Domain constrains “inside vs outside” for objectives

This prevents edge-cheating mates and makes the semantics clear.

### Recommended flow for generating moves

1. Generate all core legal moves under chess rules (with move_bound).
2. Apply laws.side_move_filter(from,to) to drop illegal-by-scenario moves.
3. Separately, the objective checks domain.inside(to) when needed.

---

# 4) Trap / tempo trap engines: how to make them constraint-aware

## 4.1 Safety trap (“inescapable trap”) solver interface

Make it take:

* a **candidate set** (states you consider for “inside” BTM positions), OR
* a generator for them (see memory section), plus
* domain.inside() for membership semantics.

**Key semantics**:
A black-to-move state p is losing for white if black can move to f such that **for all** white replies g (including pass if allowed by laws), g is outside domain.

That’s exactly what your pruning algorithm does.

## 4.2 Tempo trap should use a generalized “passability” concept

In messy script, “passable positions” were those where a WTM state is also in the trap set, so white can pass and remain inside.

Generalize to:

* a pass_allowed(state) law
* and/or a tempo_accepting(state) predicate

Then tempo trap is a Büchi game where the accepting set is:

* states where white can “spend tempo safely” (pass or equivalent)

So build your Büchi solver around:

rust
accepting(w_state) = domain.inside(w_state) && laws.pass_allowed(w_state)


This reproduces the spirit of the script but is scenario-controlled.

---

# 5) “Preference for black escape” without breaking correctness

You do **not** want preferences to alter the worst-case trap result.

So:

* Solvers stay adversarial: black always chooses any escaping move if it exists.
* Preferences only used in:

  * printing a line of play,
  * interactive play_vs_trap,
  * selecting sample states,
  * heuristic reductions (like coordinate reduction) as *optional tools*.

### Structure

Add a “strategy extraction” phase:

* After computing a trap set T, you can extract a memoryless “stay-in-trap” strategy for white:

  * For each black move p -> f, pick one white reply f -> g that returns to T.

Then preferences can pick among multiple replies.

Similarly, black preference is used only for simulation.

---

# 6) Memory bottlenecks & how to enforce limits gracefully

This is crucial: **state explosion** is the real killer.

## 6.1 The biggest memory hogs

Expect these to blow up first:

1. **Candidate state store**: HashSet<Position> of all states in the slice

   * size grows like ~((2B+1)^2)^P
2. **Move caches**: HashMap<Position, Vec<Position>> for black/white moves

   * each cached vec can be large and duplicates lots of data
3. **Derived bipartite sets** in tempo solver:

   * “WTM nodes” set, accepting set, predecessor sets, etc.
4. **Retrograde**: storing distances / predecessor lists for mate search

## 6.2 Add explicit resource limits everywhere

Add:

rust
pub struct ResourceLimits {
    pub max_states: usize,
    pub max_edges: usize,
    pub max_cache_entries: usize,
    pub max_cached_moves: usize,     // total moves across all cache entries
    pub max_runtime_steps: u64,       // optional loop iteration guard
}


Also add a standard error:

rust
pub enum SearchError {
    LimitExceeded { stage: &'static str, metric: &'static str, limit: u64, observed: u64 },
    AllocationFailed { stage: &'static str, structure: &'static str },
}


## 6.3 Track counts as you build things

Even without exact byte tracking, you can do “count budgets” that correlate strongly with memory.

Maintain a ResourceTracker updated at:

* each new state inserted
* each edge (move) generated or cached
* each cache insert

If a limit would be exceeded:

* stop early with Err(SearchError::LimitExceeded{...})
* print a message telling **which structure/stage** hit the limit

## 6.4 Use try_reserve to avoid hard OOM aborts

Rust can abort on OOM. You can proactively use try_reserve:

* Before growing a Vec of moves beyond some threshold
* Before HashSet / HashMap grows capacity

If try_reserve fails, return AllocationFailed { stage, structure }.

**Instruction to agent**: wrap big allocations and insertions with “budget-check + try_reserve”.

## 6.5 Reduce peak memory by offering solver “modes”

Give the user a config knob:

* CacheMode::None (no move caches; recompute moves each time)
* CacheMode::BlackOnly
* CacheMode::BothLRU { max_entries }

This lets big scenarios run slower but not OOM.

### Simple bounded cache strategy

Instead of implementing full LRU immediately, a cheap “bounded random eviction” works:

* if cache len exceeds max, remove e.g. 1–5 random keys (or oldest tracked by insertion order)

This keeps memory bounded and still helps.

## 6.6 Avoid building the full Cartesian product if possible

Since you now require a **starting setup**, you can offer a major optimization:

* SearchScope::ReachableFromStart

  * BFS/DFS expand only states reachable under rules+laws
  * apply domain filters to decide “inside”, but still allow “outside” transiently if needed

This is *often* orders of magnitude smaller than enumerating the full slice.

**Instruction**: keep both scopes:

* AllCandidates for “global trap set”
* ReachableFromStart for “is this start trapped / winning?”

And require the scenario choose one explicitly.

---

# 7) Tests needed to make it “convincing” after adding constraints/preferences

When you add laws/domains, tests must prove two things:

1. **the engine respects them**
2. **the objective semantics remain correct (no boundary cheating)**

## 7.1 “Engine respects laws” tests

For each law type you introduce, add at least one test where:

* core chess would allow the move,
* but the law forbids it,
* and you assert it’s absent from generated moves.

Example laws to test:

* capture forbidden
* corner clamp forbids black step
* pass only allowed when predicate holds

## 7.2 “Domain semantics” tests

Key property: leaving the domain is **not illegal**, but it counts as escape if white can’t return.

Tests should include:

* a state where black can step out but white can step back in → still inside maximal trap
* a state where black can step out and white cannot return → pruned

## 7.3 “Trap correctness” tests (higher-order)

For a computed trap set T, verify closure:

For every p ∈ T:

* for every legal black move f,

  * there exists a legal white reply g such that g ∈ T

This test is expensive; run it only on small bounds.

## 7.4 “Tempo trap correctness” tests

Your Büchi solver should produce a set TT ⊆ T.
Tests:

* TT is non-empty for known tempo scenarios
* TT contains at least one pass-allowed state
* optional: extract a witness strategy and simulate N random plays and assert you hit passable infinitely often (or frequently) — bounded simulation is not a proof but is good regression protection.

## 7.5 “Mate doesn’t use edge” regression tests

For any mate detector:

* verify that if black has a legal king move that goes outside the enumeration bound, it is **still** considered a legal escape move in mate checking.

This catches the #1 subtle bug.

---

# 8) Example plan: replicate the Python NBB trap (bishops + knight)

You asked for instructions to reproduce the messy script’s functionality “trap the king with bishops and the knight”.

Here’s how to structure it cleanly using the new scenario framework.

## 8.1 Scenario definition (config object)

Create a scenario function:

rust
pub fn nbb_box_trap() -> Scenario { ... }


It must specify:

* bound: pick something like bound = 26 (you can tune)
* move_bound: match the Python file name (e.g. 23) if you want comparability
* white_can_pass = true
* start position: REQUIRED (see below)
* laws/domain: see below
* resource limits: set high but finite

## 8.2 Domain / candidate generation (mimic Python “potential traps”)

In the Python script, they didn’t enumerate all placements; they built a **curated candidate set** via geometry constraints:

* bishops are mostly on “rim diagonals” + some special squares
* knight is near-ish by a “knight norm bound”
* king coords split edge vs center (in their absolute model)

In your **relative** model (black king fixed at origin), replicate that by defining a *domain predicate* and (optionally) per-piece coordinate lists:

### Step A: Precompute allowed squares for each piece slot

* Vec<Coord> bishop_a_squares
* Vec<Coord> bishop_b_squares
* Vec<Coord> knight_squares

These can be computed from bound and a couple of scenario parameters like n, edge_size, knight_bound.

Even if those computations use L1/knight norms internally, that’s fine: it’s **scenario code**, not a general “norm abstraction”.

### Step B: Domain predicate is just:

* pieces occupy distinct squares (already core legality)
* bishop squares are in their allowed lists
* knight square is in its allowed list
* any extra relational constraints (e.g., knight_norm(knight) < knight_bound)

### Step C: Candidate enumeration uses these lists, not full bound squares

So you don’t explode state count.

**Instruction to agent**: implement CandidateGenerator::from_per_piece_lists([&[Coord]; P]) and then filter by domain.inside(pos).

That reproduces the Python approach without making the engine messy.

## 8.3 Laws for NBB (if needed)

Depending on how faithful you want to be:

* You likely do **not** need extra laws beyond standard chess legality + move_bound.
* But if you want to mimic “corner mode” experiments, implement Law::BlackClampYMin(0) or similar.

Make it optional.

## 8.4 Starting setup requirement (important)

You must specify a concrete starting relative placement.

Best practice for reproducing Python results:

* Take **one position from the Python trap file** you already have (kNBB_20_3_2.5_23.txt)
* Convert it to your model:

  * subtract black king coordinates from white piece coordinates
  * drop the black king entry
  * order pieces consistently (N, B, B)
  * canonicalize bishops if they’re “identical” in your representation (or keep bishops distinct-by-slot to avoid color issues)

Then set that as start.position.

### Tests to add for the NBB scenario

* compute_trap(...).contains(start.position) must be true
* closure property check holds on the computed trap (small sample or full if manageable)
* tempo trap is non-empty and contains at least one pass-allowed state

**Even better**: store a *small* converted trap subset as fixture and assert it’s a subset of the computed trap.

## 8.5 Verifying the Python result (strongest regression test)

Instruction for agent:

1. Add nbb_trap_reference.txt
   (converted into your relative Position format; can be a compact line-based format)
2. In a test:

   * load the reference set into HashSet<Position>
   * compute your trap set for the same parameters
   * assert reference ⊆ computed_trap
   * optionally assert sizes match if you’ve matched parameters exactly

This makes it extremely convincing.

---

# 9) What you should tell an AI agent to implement (checklist)

Here’s a concrete “task list” you can paste into another agent:

1. **Add scenario-layer types**:

   * Scenario, StartState, ResourceLimits
   * DomainLike, LawsLike, PreferencesLike traits (or equivalent struct bundles)

2. **Refactor solvers** (trap, tempo, mate) to accept:

   * rules (existing)
   * laws filters
   * domain membership predicate
   * limits + tracker for graceful stop

3. **Add candidate generation modes**:

   * AllInBound (existing enumeration)
   * PerPieceLists(Vec<Vec<Coord>>) (for curated sets)
   * ReachableFromStart (optional but recommended)

4. **Add resource tracking + graceful error returns**:

   * enforce max_states, max_edges, max_cache_entries, max_cached_moves
   * use try_reserve before big allocations

5. **Add cache policy knobs**:

   * none / black-only / both-bounded
   * implement bounded eviction to prevent cache blowup

6. **Add tests**:

   * laws filtering tests
   * domain semantics tests (escape vs return)
   * trap closure property tests
   * tempo refinement tests
   * mate edge-nonwall tests
   * NBB scenario test verifying start is trapped (and preferably reference subset inclusion)

7. **Add NBB scenario** (like this: https://raw.githubusercontent.com/mjtb49/InfiniteChessEndgameScripts/refs/heads/main/trap_tester.py )

   * per-piece allowed-square generators (scenario-local, not general abstractions)
   * start position from converted Python trap file
   * run trap + tempo; assert non-empty + start included

Think very deeply about the structure and write clean, understandable, well structured, extendable, well tested code! Feel free to redesign bigger components of the current version of the project if you feel like another code/file structure might be more suitable!
Use cargo check, test, fmt, run.

Review ~/infinite_chess/BBN_script as well to reproduce its trap (not precisely, just to show that some formation of same colour bishops and knights can trap the king. If you can't that's fine, but try to come up with an answer why, and don't run too heavy processes (limit memory usage and kill if too much) when experimenting!

Explored 21 files, 2 searches, 3 lists
Listed files
Searched for AGENTS.md in ..
Searched for *.rs in .
Listed files
Read Cargo.toml
Read lib.rs
Read buchi.rs
Read mates.rs
Read position.rs
Read config.rs
Read layout.rs
Read piece.rs
Read trap_search.rs
Read mate_search.rs
Read README.md
Read trap.rs
Listed files in tests
Read known_results.rs
Read rules.rs
Read coord.rs
Read square.rs
Read mod.rs
Read bounds.rs
Read trap_tester.py
Read infinite_tablebase.py
Read kNBB_20_3_2.5_23.txt
Ran command
$ wc -l BBN_script/InfiniteChessEndgameScripts/kNBB_20_3_2.5_23.txt

0 BBN_script/InfiniteChessEndgameScripts/kNBB_20_3_2.5_23.txt
0 BBN_script/InfiniteChessEndgameScripts/kNBB_20_3_2.5_23.txt

Success
Explored 2 files, 3 searches
Searched for BLACK_KING_INDEX|PIECES\s*=|CORNER_MODE|CORNER_BOUND|kNBB in trap_tester.py
Searched for coord_reduc|reduc in .
Read README.md
Searched for def find_maximal_inescapable|def find_maximal_inescapable_tempo in trap_tester.py
Read trap_tester.py
Ran command
$ cargo test -q


running 2 tests
..
test result: ok. 2 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s


running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s


running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s


running 4 tests
....
test result: ok. 4 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.12s


running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s


running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s


Success
Explored 1 list
Listed files in kNBB_20_3_2.5_23.txt
Ran command for 1s
$ python3 - <<'PY'
import re
from pathlib import Path
p=Path('BBN_script/InfiniteChessEndgameScripts/kNBB_20_3_2.5_23.txt')
text=p.read_text()
# stream ints
ints=(int(m.group(0)) for m in re.finditer(r'-?\\d+', text))
uniq=set()
count=0
buf=[]
for x in ints:
    buf.append(x)
    if len(buf)==8:
        kx,ky, a,b, c,d, e,f = buf
        rel=[(a-kx,b-ky),(c-kx,d-ky),(e-kx,f-ky)]
        rel.sort()
        uniq.add(tuple(rel))
        count+=1
        buf.clear()
print('positions',count)
print('unique_rel',len(uniq))
# show a few examples
for i,t in enumerate(list(uniq)[:5]):
    print(t)
PY

positions 217208
unique_rel 193464
((-1, 5), (2, 0), (6, -4))
((-3, -27), (-3, 2), (-3, 13))
((-2, -11), (0, -4), (17, 10))
((-27, 11), (1, -3), (12, 10))
((-9, -9), (-2, 3), (9, 13))

Success

Asked 3 questions
Keep the current king-relative model (black king fixed at origin), or extend the state to include the black king’s absolute coordinate so laws like “king can’t cross y=0” are representable?
If it's possible, make them optional: if there are any constraints about the absolute position, track the abs king position. If not, ignore. Some version of it will have to be tracked anyway for checking whether or not it can escape the region
How should the built-in NBB scenario be sourced?
Attempt to use something that resembles the shape of the file, if you cannot reproduce a trapping strategy, try, and if unsuccessful, try to explain why
Is it OK to break the current public API (e.g., replace `ScenarioConfig` + change solver signatures to return `Result` with `SearchError`)?
Yes, a well designed net for possible errors would be good. Like did it break because there were too many states/options, or because the black king escaped everywhere (although that would be a no result), etc, including the number of examined states, etc
Explored 1 search
Searched for ScenarioConfig in .
Ran command
$ python3 - <<'PY'
import math

def l1_norm(a):
    return abs(a[0])+abs(a[1])

def knight_norm(a):
    r,s=abs(a[0]),abs(a[1])
    return max(r,s)/2 if 2*min(r,s) < max(r,s) else (r+s)/3

def dist(a,b):
    return knight_norm((a[0]-b[0],a[1]-b[1]))

def counts(n, knight_bound, edge_size):
    special_bishops=[(1-n,0),(n-1,0),(0,1-n),(0,n-1)]
    bishop_1=[(a,b) for a in range(-n,n+1) for b in range(-n,n+1) if a+b in {n+1,-n-1}] + special_bishops
    bishop_2=[(a,b) for a in range(-n,n+1) for b in range(-n,n+1) if a-b in {n+1,-n-1}] + special_bishops
    all_bishops=[(a,b) for a in bishop_1 for b in bishop_2 if len((set(a)|set(b)).intersection({n,-n,n-1,1-n}))>0]
    bishops_corner=[(a,b) for a in bishop_1 for b in bishop_2 if len(set(a).intersection({n,-n}))>0 and len(set(b).intersection({n,-n}))>0]
    knight=[(a,b) for a in range(-n-3,n+4) for b in range(-n-3,n+4) if l1_norm((a,b))<=n+3]
    edge_k=[(a,b) for a in range(-n,n+1) for b in range(-n,n+1) if n-edge_size<=l1_norm((a,b))<=n]
    center_k=[(a,b) for a in range(-n,n+1) for b in range(-n,n+1) if l1_norm((a,b))<n-edge_size]
    # count pairs satisfying dist<knight_bound
    def count_knight_near(kings):
        cnt=0
        for a in kings:
            for b in knight:
                if dist(a,b)<knight_bound:
                    cnt+=1
        return cnt
    cn=count_knight_near(center_k)
    en=count_knight_near(edge_k)
    print('bishop_1',len(bishop_1),'bishop_2',len(bishop_2),'all_bishops_pairs',len(all_bishops),'corner_pairs',len(bishops_corner))
    print('knight_squares',len(knight),'edge_kings',len(edge_k),'center_kings',len(center_k))
    print('king-knight pairs: center',cn,'edge',en)
    # total potential positions size:
    total=cn*len(bishops_corner)+en*len(all_bishops)
    print('approx total candidates',total)

counts(20,2.5,3)
PY

bishop_1 44 bishop_2 44 all_bishops_pairs 912 corner_pairs 16
knight_squares 1105 edge_kings 296 center_kings 545
king-knight pairs: center 41965 edge 20320
approx total candidates 19203280
bishop_1 44 bishop_2 44 all_bishops_pairs 912 corner_pairs 16
knight_squares 1105 edge_kings 296 center_kings 545
king-knight pairs: center 41965 edge 20320
approx total candidates 19203280

Success
Plan
Open

Scenario Layering + Constraint-Aware Solvers (with budgets)
Summary
Refactor the codebase so pure chess rules stay isolated, while scenario-specific constraints are expressed as:

Laws: move legality filters applied after core movegen
Domain: “inside vs outside” membership for trap objectives (leaving is allowed; it’s just losing/winning depending on objective)
Objective: trap / tempo trap / mate checks, all consuming the same Rules+Laws+Domain
Preferences: non-adversarial move ordering used only for demos/strategy extraction
Add ResourceLimits + SearchError so large searches fail gracefully (with stage + counters) instead of OOM.
This includes an optional absolute black-king coordinate in the state: tracked only when a scenario needs absolute constraints (e.g., Python-style “king within a box/corner”), otherwise kept constant so the state space stays translation-reduced.

Public API / Interface Changes (breaking, by design)
Replace chess::config::ScenarioConfig with a new scenario::Scenario<Domain, Laws, Preferences> plus required StartState.
Change solvers to return Result<_, SearchError> instead of panicking or silently OOMing.
Introduce scenario::{State, Side, StartState, ResourceLimits, SearchError, CacheMode, CandidateGeneration}.
Core Types (new module)
Create mod.rs exporting:

1) State + start
enum Side { Black, White }
struct State { abs_king: Coord, pos: Position }
pos remains king-relative (as today).
abs_king is a global anchor only when needed.
struct StartState { to_move: Side, state: State }
Start is required for every scenario.
2) Limits + errors
struct ResourceLimits {
max_states: usize
max_edges: usize
max_cache_entries: usize
max_cached_moves: usize
max_runtime_steps: u64
struct ResourceCounts { states, edges, cache_entries, cached_moves, runtime_steps }
enum SearchError {
InvalidScenario { reason: String }
LimitExceeded { stage: &'static str, metric: &'static str, limit: u64, observed: u64, counts: ResourceCounts }
AllocationFailed { stage: &'static str, structure: &'static str, counts: ResourceCounts }
Io { stage: &'static str, path: String, error: String } (for NBB file loading)
}
3) Laws / Domain / Preferences traits
Use inlined, static-dispatch-friendly traits:

trait DomainLike { fn inside(&self, s: &State) -> bool; }
trait LawsLike {
fn allow_state(&self, s: &State) -> bool { true }
fn allow_black_move(&self, from: &State, to: &State, delta: Coord) -> bool { true }
fn allow_white_move(&self, from: &State, to: &State) -> bool { true }
fn allow_pass(&self, s: &State) -> bool { true }
}
trait PreferencesLike {
fn rank_black_moves(&self, from: &State, moves: &[State]) -> Vec<usize>
fn rank_white_moves(&self, from: &State, moves: &[State]) -> Vec<usize>
}
Provide defaults:

struct NoLaws;
struct AllDomain;
struct NoPreferences;
4) Candidate generation + cache config
enum CandidateGeneration {
InLinfBound { bound: i32, allow_captures: bool } (relative enumeration, current behavior)
FromStates { states: Vec<State> } (precomputed/loaded)
ReachableFromStart { max_queue: usize } (BFS, optional but implemented)
}
enum CacheMode { None, BlackOnly, BothBounded }
5) Scenario struct
struct Scenario<D, L, P> {
name: &'static str
rules: Rules (constructed from layout + move_bound)
white_can_pass: bool
track_abs_king: bool (if false, black moves keep abs_king unchanged)
start: StartState
candidates: CandidateGeneration
domain: D
laws: L
preferences: P
limits: ResourceLimits
cache_mode: CacheMode
remove_stalemates: bool (kept as domain-like filter but implemented with law-aware stalemate check)
}
Scenario validation (called by CLIs + tests):

Start is legal under Rules
Start passes laws.allow_state and domain.inside
If remove_stalemates, start is not stalemate when to_move == Black
If candidates == InLinfBound, start’s pieces are within that bound (when present)
Rules Layer (pure chess)
Keep rules.rs as the “Rules” layer, but refactor black movegen slightly:

Add:
Rules::black_moves_with_delta(&self, pos: &Position) -> Vec<(Coord, Position)>
Keep existing:
Rules::black_moves(&self, pos: &Position) -> Vec<Position> delegating to the above.
No scenario logic in Rules.

Laws-aware Move Generation (new helpers)
Add movegen.rs (or movegen.rs) implementing:

fn legal_black_moves(scn: &Scenario<..>, laws: &impl LawsLike, s: &State, tracker: &mut ResourceTracker) -> Result<Vec<State>, SearchError>
Iterate king deltas
Build next Position via Rules::black_moves_with_delta
Update abs_king only if track_abs_king
Filter by laws.allow_black_move(from,to,delta) and laws.allow_state(to)
fn legal_white_moves(...) -> Result<Vec<State>, SearchError>
Pass is included iff scn.white_can_pass && laws.allow_pass(state)
Filter each move by laws.allow_white_move and laws.allow_state
Also add:

is_checkmate_with_laws(rules, laws, scn, state) -> bool
is_stalemate_with_laws(...) -> bool
These are used by the “remove stalemates from domain” behavior and by mate objectives when needed.

Resource tracking (budgets everywhere)
Add resources.rs:

struct ResourceTracker { limits: ResourceLimits, counts: ResourceCounts }
fn bump_states(stage, +1)
fn bump_edges(stage, +n)
fn bump_cache_entries(stage, +1)
fn bump_cached_moves(stage, +n)
fn bump_steps(stage, +1)
Each bump checks limits and returns SearchError::LimitExceeded with counts snapshot.
Use try_reserve before large Vec/HashSet/HashMap growth; on failure return AllocationFailed.
Trap Solver (Domain + Laws aware)
Refactor trap.rs:

maximal_inescapable_trap
Signature:

pub fn maximal_inescapable_trap<D: DomainLike, L: LawsLike>(scn: &Scenario<D, L, impl PreferencesLike>) -> Result<FxHashSet<State>, SearchError>
Algorithm:

Build initial candidate set S0 from scn.candidates:
For InLinfBound: enumerate positions in bound (as today), wrap as State { abs_king=ORIGIN, pos }, then filter by:
rules.is_legal_position
laws.allow_state
domain.inside
remove_stalemates => !is_stalemate_with_laws(...)
For FromStates: insert provided states after filtering legality/laws/domain.
For ReachableFromStart: BFS alternating sides from start, tracking visited; collect only black-to-move states that satisfy legality/laws/domain (and optionally stalemate exclusion), with budgets enforced.
Fixed-point pruning as today, but using legal_black_moves / legal_white_moves.
Leaving the domain is never illegal: black moves are generated without domain checks; only the “reply exists in current trap set” check matters.
Move caching:

Replace cloning cache with Arc<[State]> caches to avoid duplicating move vectors.
Enforce max_cache_entries and max_cached_moves.
Implement deterministic eviction (remove arbitrary keys until under limit).
Return: maximal trap set of black-to-move States.

maximal_tempo_trap
Refactor to accept State trap sets and use law-aware movegen.

Tempo Trap (Büchi) Solver (constraint-aware)
Refactor buchi.rs:

Accept &FxHashSet<State> for btm_trap.
Build bipartite graph:
B nodes = btm_trap
W nodes = union of legal_black_moves(b)
W -> B edges = legal_white_moves(w) filtered to those whose resulting black state is in btm_trap
Acceptance set:
accept(w) = (btm_trap.contains(w_as_black_state) && can_pass(w))
Here w_as_black_state is the same placement but with black to move (same State value).
Enforce max_edges and max_states during graph build.
Keep the existing “dead-end handling” semantics (don’t count terminal nodes as Büchi-winning).

Preferences (strategy extraction, not correctness)
Add strategy.rs:

extract_white_stay_strategy(...) -> FxHashMap<State /*w node*/, State /*chosen b node*/>
Optional CLI feature: print a sample line by picking black moves by preference and white replies by extracted strategy.
Preferences never affect trap/tempo set computation—only move selection for demo.

Update built-in scenarios
Refactor mod.rs:

Return Scenario<AllDomain, NoLaws, NoPreferences> for the two existing scenarios.
Add a small, legal start for each (fixed squares within bound).
Keep the old names working in CLIs.
Add nbb.rs:

Provide pub fn nbb20_from_file() -> Scenario<AllDomain, NoLaws, NoPreferences>
Reads kNBB_20_3_2.5_23.txt
Streaming int parser (8 ints per position) → (king, knight, bishop, bishop) absolute coords
Convert to State { abs_king=king, pos = relative(Position([B,B,N])) }
track_abs_king = true
candidates = CandidateGeneration::FromStates { states }
Start = first parsed legal state, to_move=Black
limits tuned to avoid OOM (e.g., max_states ~ 400_000, caches bounded)
If this doesn’t yield a non-empty trap, document the likely cause (rules mismatch vs script, pass semantics, etc.) and keep it as a best-effort demo rather than forcing heavy regeneration of the 19M candidate universe.
CLIs
Update:

trap_search.rs to:
load scenario by name (now returning an enum or boxed trait object that runs the right generic code)
print scenario + limits
run trap + tempo trap
on SearchError, print stage, metric, limit, observed, and all counters.
mate_search.rs:
keep current “pure rules” mate counting OR add --laws path later; for now, keep behavior but adapt to new scenario struct.
Tests (fast + convincing)
Update known_results.rs to new API and keep the same expected values.

Add:

laws.rs
Capture forbidden law: craft a position where black can capture a rook; assert capture move disappears when NoCapturesLaws is active.
Pass predicate law: restrict pass to a predicate; assert pass presence depends on state.
domain_semantics.rs
Use CandidateGeneration::FromStates with a tiny hand-built domain to prove:
“leave domain is allowed but not escape if white can return”
“escape if white cannot return”
mate_nonwall.rs
Ensure mate checking (with laws-aware movegen) still considers black moves that shift pieces outside any enumeration bound.
Add an ignored test nbb20.rs:

Loads/parses the 8.5MB Python trap file and asserts trap+tempo non-empty under limits.
Mark #[ignore] so CI stays fast; document how to run it locally.
Commands to run (end-to-end verification)
cargo fmt
cargo check
cargo test
cargo run --release --bin trap_search -- three_rooks_bound2_mb1
cargo test -- --ignored (optional, for NBB file demo)
Assumptions / defaults
Default state is king-relative; abs_king is only meaningful when Scenario.track_abs_king=true.
Laws/Domain/Preferences are compile-time types (no dynamic dispatch in tight loops).
NBB reproduction uses the provided Python trap file as a domain (practical), because regenerating the original ~19M potential positions is too heavy for routine runs; a “geometry-only generator” can be added later behind a feature flag if desired.
Implement plan

Created
mod.rs
+286
-0
mod.rs
+286
-0

//! Scenario layer: glue between pure chess rules and game-search objectives.
//!
//! This module defines:
//! - `State`: a piece placement plus an optional absolute black-king anchor
//! - `Scenario`: a fully specified search configuration (rules + laws + domain + limits)
//! - Traits for `LawsLike`, `DomainLike`, and `PreferencesLike`

use std::fmt;

use crate::chess::bounds::is_in_bound;
use crate::chess::rules::Rules;
use crate::core::coord::Coord;
use crate::core::position::Position;

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum Side {
    Black,
    White,
}

/// A game state for "white pieces vs lone black king".
///
/// - `pos` is stored in king-relative coordinates (black king at origin).
/// - `abs_king` is an optional absolute anchor used only when a scenario needs absolute constraints.
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct State {
    pub abs_king: Coord,
    pub pos: Position,
}

impl State {
    #[inline]
    pub fn new(abs_king: Coord, pos: Position) -> Self {
        Self { abs_king, pos }
    }
}

#[derive(Debug, Clone, PartialEq, Eq)]
pub struct StartState {
    pub to_move: Side,
    pub state: State,
}

#[derive(Debug, Clone, Copy)]
pub struct ResourceLimits {
    pub max_states: usize,
    pub max_edges: usize,
    pub max_cache_entries: usize,
    pub max_cached_moves: usize,
    pub max_runtime_steps: u64,
}

impl Default for ResourceLimits {
    fn default() -> Self {
        Self {
            max_states: 2_000_000,
            max_edges: 50_000_000,
            max_cache_entries: 250_000,
            max_cached_moves: 15_000_000,
            max_runtime_steps: 200_000_000,
        }
    }
}

#[derive(Debug, Clone, Copy, Default)]
pub struct ResourceCounts {
    pub states: u64,
    pub edges: u64,
    pub cache_entries: u64,
    pub cached_moves: u64,
    pub runtime_steps: u64,
}

#[derive(Debug)]
pub enum SearchError {
    InvalidScenario { reason: String },
    LimitExceeded {
        stage: &'static str,
        metric: &'static str,
        limit: u64,
        observed: u64,
        counts: ResourceCounts,
    },
    AllocationFailed {
        stage: &'static str,
        structure: &'static str,
        counts: ResourceCounts,
    },
    Io {
        stage: &'static str,
        path: String,
        error: String,
    },
}

impl fmt::Display for SearchError {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            SearchError::InvalidScenario { reason } => write!(f, "invalid scenario: {reason}"),
            SearchError::LimitExceeded {
                stage,
                metric,
                limit,
                observed,
                counts,
            } => write!(
                f,
                "limit exceeded at {stage}: {metric} (limit={limit}, observed={observed}); \
                 counts(states={}, edges={}, cache_entries={}, cached_moves={}, runtime_steps={})",
                counts.states, counts.edges, counts.cache_entries, counts.cached_moves, counts.runtime_steps
            ),
            SearchError::AllocationFailed {
                stage,
                structure,
                counts,
            } => write!(
                f,
                "allocation failed at {stage} for {structure}; \
                 counts(states={}, edges={}, cache_entries={}, cached_moves={}, runtime_steps={})",
                counts.states, counts.edges, counts.cache_entries, counts.cached_moves, counts.runtime_steps
            ),
            SearchError::Io { stage, path, error } => {
                write!(f, "io error at {stage} for {path}: {error}")
            }
        }
    }
}

impl std::error::Error for SearchError {}

pub trait DomainLike {
    fn inside(&self, s: &State) -> bool;
}

pub trait LawsLike {
    #[inline]
    fn allow_state(&self, _s: &State) -> bool {
        true
    }

    #[inline]
    fn allow_black_move(&self, _from: &State, _to: &State, _delta: Coord) -> bool {
        true
    }

    #[inline]
    fn allow_white_move(&self, _from: &State, _to: &State) -> bool {
        true
    }

    #[inline]
    fn allow_pass(&self, _s: &State) -> bool {
        true
    }
}

pub trait PreferencesLike {
    fn rank_black_moves(&self, from: &State, moves: &[State]) -> Vec<usize>;
    fn rank_white_moves(&self, from: &State, moves: &[State]) -> Vec<usize>;
}

#[derive(Debug, Clone, Copy, Default)]
pub struct NoLaws;
impl LawsLike for NoLaws {}

#[derive(Debug, Clone, Copy, Default)]
pub struct AllDomain;
impl DomainLike for AllDomain {
    #[inline]
    fn inside(&self, _s: &State) -> bool {
        true
    }
}

#[derive(Debug, Clone, Copy, Default)]
pub struct NoPreferences;
impl PreferencesLike for NoPreferences {
    fn rank_black_moves(&self, _from: &State, moves: &[State]) -> Vec<usize> {
        (0..moves.len()).collect()
    }

    fn rank_white_moves(&self, _from: &State, moves: &[State]) -> Vec<usize> {
        (0..moves.len()).collect()
    }
}

#[derive(Debug, Clone)]
pub enum CandidateGeneration {
    InLinfBound { bound: i32, allow_captures: bool },
    FromStates { states: Vec<State> },
    ReachableFromStart { max_queue: usize },
}

#[derive(Debug, Clone, Copy)]
pub enum CacheMode {
    None,
    BlackOnly,
    BothBounded,
}

#[derive(Debug, Clone)]
pub struct Scenario<D, L, P> {
    pub name: &'static str,
    pub rules: Rules,
    pub white_can_pass: bool,
    pub track_abs_king: bool,
    pub start: StartState,
    pub candidates: CandidateGeneration,
    pub domain: D,
    pub laws: L,
    pub preferences: P,
    pub limits: ResourceLimits,
    pub cache_mode: CacheMode,
    pub remove_stalemates: bool,
}

impl<D: DomainLike, L: LawsLike, P: PreferencesLike> Scenario<D, L, P> {
    pub fn validate(&self) -> Result<(), SearchError> {
        let s = &self.start.state;

        if !self.track_abs_king && s.abs_king != Coord::ORIGIN {
            return Err(SearchError::InvalidScenario {
                reason: "track_abs_king=false requires start.abs_king == ORIGIN".to_string(),
            });
        }

        if !self.rules.is_legal_position(&s.pos) {
            return Err(SearchError::InvalidScenario {
                reason: "start position is not legal under pure rules".to_string(),
            });
        }

        if !self.laws.allow_state(s) {
            return Err(SearchError::InvalidScenario {
                reason: "start state rejected by laws.allow_state".to_string(),
            });
        }

        if !self.domain.inside(s) {
            return Err(SearchError::InvalidScenario {
                reason: "start state is outside the domain".to_string(),
            });
        }

        if let CandidateGeneration::InLinfBound { bound, .. } = self.candidates {
            for &sq in s.pos.squares() {
                if !is_in_bound(sq, bound) {
                    return Err(SearchError::InvalidScenario {
                        reason: format!("start has a piece outside the L∞ bound {bound}"),
                    });
                }
            }
        }

        if self.remove_stalemates && self.start.to_move == Side::Black && self.is_stalemate_under_laws(s) {
            return Err(SearchError::InvalidScenario {
                reason: "start is a stalemate (and remove_stalemates=true)".to_string(),
            });
        }

        Ok(())
    }

    fn is_stalemate_under_laws(&self, s: &State) -> bool {
        if self.rules.is_attacked(Coord::ORIGIN, &s.pos) {
            return false;
        }

        for (delta, pos2) in self.rules.black_moves_with_delta(&s.pos) {
            let to = State {
                abs_king: if self.track_abs_king {
                    s.abs_king + delta
                } else {
                    s.abs_king
                },
                pos: pos2,
            };
            if self.laws.allow_black_move(s, &to, delta) && self.laws.allow_state(&to) {
                return false;
            }
        }

        true
    }
}

Edited file
lib.rs
+1
-0

pub mod core;
pub mod scenario;
pub mod scenarios;
Edited file
rules.rs
+13
-2

    pub fn black_moves(&self, pos: &Position) -> Vec<Position> {
        let mut out = Vec::new();
        self.black_moves_with_delta(pos)
            .into_iter()
            .map(|(_, p)| p)
            .collect()
    }

    /// All legal black king moves, paired with the king step `delta` taken in the *current*
    /// king-relative coordinate system.
    ///
    /// This is useful for scenarios that track an absolute king anchor.
    pub fn black_moves_with_delta(&self, pos: &Position) -> Vec<(Coord, Position)> {
        let mut out: Vec<(Coord, Position)> = Vec::new();

        for &delta in &KING_STEPS {

            out.push(next);
            out.push((delta, next));
        }
Created
resources.rs
+151
-0
resources.rs
+151
-0

use crate::scenario::{ResourceCounts, ResourceLimits, SearchError};

#[derive(Debug, Clone)]
pub struct ResourceTracker {
    limits: ResourceLimits,
    counts: ResourceCounts,
}

impl ResourceTracker {
    #[inline]
    pub fn new(limits: ResourceLimits) -> Self {
        Self {
            limits,
            counts: ResourceCounts::default(),
        }
    }

    #[inline]
    pub fn counts(&self) -> ResourceCounts {
        self.counts
    }

    #[inline]
    pub fn bump_states(&mut self, stage: &'static str, delta: usize) -> Result<(), SearchError> {
        self.bump(stage, "states", delta as u64, self.limits.max_states as u64, |c| {
            &mut c.states
        })
    }

    #[inline]
    pub fn bump_edges(&mut self, stage: &'static str, delta: usize) -> Result<(), SearchError> {
        self.bump(stage, "edges", delta as u64, self.limits.max_edges as u64, |c| &mut c.edges)
    }

    #[inline]
    pub fn bump_cache_entries(
        &mut self,
        stage: &'static str,
        delta: usize,
    ) -> Result<(), SearchError> {
        self.bump(
            stage,
            "cache_entries",
            delta as u64,
            self.limits.max_cache_entries as u64,
            |c| &mut c.cache_entries,
        )
    }

    #[inline]
    pub fn bump_cached_moves(
        &mut self,
        stage: &'static str,
        delta: usize,
    ) -> Result<(), SearchError> {
        self.bump(
            stage,
            "cached_moves",
            delta as u64,
            self.limits.max_cached_moves as u64,
            |c| &mut c.cached_moves,
        )
    }

    #[inline]
    pub fn bump_steps(&mut self, stage: &'static str, delta: u64) -> Result<(), SearchError> {
        self.bump(
            stage,
            "runtime_steps",
            delta,
            self.limits.max_runtime_steps,
            |c| &mut c.runtime_steps,
        )
    }

    fn bump(
        &mut self,
        stage: &'static str,
        metric: &'static str,
        delta: u64,
        limit: u64,
        field: impl FnOnce(&mut ResourceCounts) -> &mut u64,
    ) -> Result<(), SearchError> {
        let observed = {
            let v = field(&mut self.counts);
            *v = v.saturating_add(delta);
            *v
        };

        if observed > limit {
            return Err(SearchError::LimitExceeded {
                stage,
                metric,
                limit,
                observed,
                counts: self.counts,
            });
        }

        Ok(())
    }

    pub fn try_reserve_vec<T>(
        &self,
        stage: &'static str,
        structure: &'static str,
        v: &mut Vec<T>,
        additional: usize,
    ) -> Result<(), SearchError> {
        v.try_reserve(additional).map_err(|_| SearchError::AllocationFailed {
            stage,
            structure,
            counts: self.counts,
        })
    }

    pub fn try_reserve_set<K>(
        &self,
        stage: &'static str,
        structure: &'static str,
        set: &mut rustc_hash::FxHashSet<K>,
        additional: usize,
    ) -> Result<(), SearchError>
    where
        K: std::hash::Hash + Eq,
    {
        set.try_reserve(additional).map_err(|_| SearchError::AllocationFailed {
            stage,
            structure,
            counts: self.counts,
        })
    }

    pub fn try_reserve_map<K, V>(
        &self,
        stage: &'static str,
        structure: &'static str,
        map: &mut rustc_hash::FxHashMap<K, V>,
        additional: usize,
    ) -> Result<(), SearchError>
    where
        K: std::hash::Hash + Eq,
    {
        map.try_reserve(additional).map_err(|_| SearchError::AllocationFailed {
            stage,
            structure,
            counts: self.counts,
        })
    }
}

Created
movegen.rs
+107
-0
movegen.rs
+107
-0

use crate::scenario::{DomainLike, LawsLike, Scenario, SearchError, State};
use crate::search::resources::ResourceTracker;

pub fn legal_black_moves<D, L, P>(
    scn: &Scenario<D, L, P>,
    laws: &L,
    s: &State,
    tracker: &mut ResourceTracker,
) -> Result<Vec<State>, SearchError>
where
    D: DomainLike,
    L: LawsLike,
{
    let mut out: Vec<State> = Vec::with_capacity(8);

    for (delta, pos2) in scn.rules.black_moves_with_delta(&s.pos) {
        let to = State {
            abs_king: if scn.track_abs_king {
                s.abs_king + delta
            } else {
                s.abs_king
            },
            pos: pos2,
        };

        if !laws.allow_black_move(s, &to, delta) {
            continue;
        }
        if !laws.allow_state(&to) {
            continue;
        }

        out.push(to);
    }

    tracker.bump_edges("movegen_black", out.len())?;
    Ok(out)
}

pub fn legal_white_moves<D, L, P>(
    scn: &Scenario<D, L, P>,
    laws: &L,
    s: &State,
    tracker: &mut ResourceTracker,
) -> Result<Vec<State>, SearchError>
where
    D: DomainLike,
    L: LawsLike,
{
    let mut out: Vec<State> = Vec::new();

    if scn.white_can_pass && laws.allow_pass(s) {
        out.push(s.clone());
    }

    for pos2 in scn.rules.white_moves(&s.pos, false) {
        let to = State {
            abs_king: s.abs_king,
            pos: pos2,
        };

        if !laws.allow_white_move(s, &to) {
            continue;
        }
        if !laws.allow_state(&to) {
            continue;
        }

        out.push(to);
    }

    tracker.bump_edges("movegen_white", out.len())?;
    Ok(out)
}

pub fn is_checkmate_with_laws<D, L, P>(
    scn: &Scenario<D, L, P>,
    laws: &L,
    s: &State,
    tracker: &mut ResourceTracker,
) -> Result<bool, SearchError>
where
    D: DomainLike,
    L: LawsLike,
{
    if !scn.rules.is_attacked(crate::core::coord::Coord::ORIGIN, &s.pos) {
        return Ok(false);
    }
    Ok(legal_black_moves(scn, laws, s, tracker)?.is_empty())
}

pub fn is_stalemate_with_laws<D, L, P>(
    scn: &Scenario<D, L, P>,
    laws: &L,
    s: &State,
    tracker: &mut ResourceTracker,
) -> Result<bool, SearchError>
where
    D: DomainLike,
    L: LawsLike,
{
    if scn.rules.is_attacked(crate::core::coord::Coord::ORIGIN, &s.pos) {
        return Ok(false);
    }
    Ok(legal_black_moves(scn, laws, s, tracker)?.is_empty())
}

Edited file
mod.rs
+3
-0

pub mod mates;
pub mod movegen;
pub mod resources;
pub mod strategy;
pub mod trap;
Created
strategy.rs
+54
-0
strategy.rs
+54
-0

use rustc_hash::FxHashMap;

use crate::scenario::{DomainLike, LawsLike, PreferencesLike, Scenario, SearchError, State};
use crate::search::movegen::{legal_black_moves, legal_white_moves};
use crate::search::resources::ResourceTracker;

/// Extract a memoryless "stay in trap" strategy for White.
///
/// Returns a map from white-to-move nodes (states that arise after a black move) to a
/// chosen black-to-move successor that stays inside `btm_trap`.
///
/// Preferences are only used to break ties among multiple staying replies.
pub fn extract_white_stay_strategy<D, L, P>(
    scn: &Scenario<D, L, P>,
    btm_trap: &rustc_hash::FxHashSet<State>,
) -> Result<FxHashMap<State, State>, SearchError>
where
    D: DomainLike,
    L: LawsLike,
    P: PreferencesLike,
{
    let mut tracker = ResourceTracker::new(scn.limits);
    let mut out: FxHashMap<State, State> = FxHashMap::default();

    for b in btm_trap.iter() {
        tracker.bump_steps("strategy_extract", 1)?;

        for w in legal_black_moves(scn, &scn.laws, b, &mut tracker)? {
            if out.contains_key(&w) {
                continue;
            }

            let replies = legal_white_moves(scn, &scn.laws, &w, &mut tracker)?;
            let mut stay: Vec<State> = replies
                .into_iter()
                .filter(|r| btm_trap.contains(r))
                .collect();
            if stay.is_empty() {
                continue;
            }

            let ranking = scn.preferences.rank_white_moves(&w, &stay);
            let choice = ranking
                .into_iter()
                .find_map(|idx| stay.get(idx).cloned())
                .unwrap_or_else(|| stay.swap_remove(0));

            out.insert(w, choice);
        }
    }

    Ok(out)
}

Edited file
resources.rs
+10
-1

    #[inline]
    pub fn dec_cache_entries(&mut self, delta: usize) {
        self.counts.cache_entries = self.counts.cache_entries.saturating_sub(delta as u64);
    }

    #[inline]
    pub fn bump_cached_moves(
    #[inline]
    pub fn dec_cached_moves(&mut self, delta: usize) {
        self.counts.cached_moves = self.counts.cached_moves.saturating_sub(delta as u64);
    }

    #[inline]
    pub fn bump_steps(&mut self, stage: &'static str, delta: u64) -> Result<(), SearchError> {
}

Deleted
trap.rs
+0
-103
trap.rs
+0
-103

use rustc_hash::{FxHashMap, FxHashSet};

use crate::chess::bounds::enumerate_positions_in_bound;
use crate::chess::config::ScenarioConfig;
use crate::chess::rules::Rules;
use crate::core::position::Position;

/// Cache for move generation during trap pruning.
#[derive(Default)]
struct MoveCache {
    black: FxHashMap<Position, Vec<Position>>,
    white: FxHashMap<Position, Vec<Position>>,
}

impl MoveCache {
    fn black_moves(&mut self, rules: &Rules, p: &Position) -> Vec<Position> {
        if let Some(v) = self.black.get(p) {
            return v.clone();
        }
        let moves = rules.black_moves(p);
        self.black.insert(p.clone(), moves.clone());
        moves
    }

    fn white_moves(&mut self, rules: &Rules, p: &Position, white_can_pass: bool) -> Vec<Position> {
        // Keying only by `Position` is OK because `white_can_pass` is config-global.
        if let Some(v) = self.white.get(p) {
            return v.clone();
        }
        let moves = rules.white_moves(p, white_can_pass);
        self.white.insert(p.clone(), moves.clone());
        moves
    }
}

/// Compute the maximal inescapable trap inside the scenario's L∞ slice.
///
/// The returned set is a set of **black-to-move** positions within the bound.
pub fn maximal_inescapable_trap(cfg: &ScenarioConfig) -> FxHashSet<Position> {
    let rules = Rules::new(cfg.layout.clone(), cfg.move_bound);

    let mut trap: FxHashSet<Position> =
        enumerate_positions_in_bound(&rules.layout, cfg.bound, true)
            .into_iter()
            .filter(|p| rules.is_legal_position(p))
            .collect();

    if cfg.remove_stalemates {
        trap.retain(|p| !rules.is_stalemate(p));
    }

    let mut cache = MoveCache::default();

    loop {
        let mut to_remove: Vec<Position> = Vec::new();

        for p in trap.iter() {
            // If black has a move to a position from which every white reply exits the current set,
            // then `p` cannot be in an inescapable trap.
            let black_moves = cache.black_moves(&rules, p);

            let mut fails = false;
            for after_black in black_moves.iter() {
                let white_moves = cache.white_moves(&rules, after_black, cfg.white_can_pass);
                let has_reply_in_trap = white_moves.iter().any(|q| trap.contains(q));
                if !has_reply_in_trap {
                    fails = true;
                    break;
                }
            }

            if fails {
                to_remove.push(p.clone());
            }
        }

        if to_remove.is_empty() {
            break;
        }
        for p in to_remove {
            trap.remove(&p);
        }
    }

    trap
}

/// Compute the maximal *tempo* trap inside an already-computed inescapable trap.
///
/// A tempo trap is the Büchi-winning region where White can:
/// 1) stay inside the inescapable trap forever, and
/// 2) force *infinitely many* visits to "passable" white-to-move positions.
///
/// "Passable" means: after Black's move, the resulting piece placement is itself
/// a black-to-move trap position, so White may pass and still remain inside the trap.
pub fn maximal_tempo_trap(
    cfg: &ScenarioConfig,
    inescapable: &FxHashSet<Position>,
) -> FxHashSet<Position> {
    let rules = Rules::new(cfg.layout.clone(), cfg.move_bound);

    crate::search::buchi::tempo_trap_buchi(&rules, inescapable, cfg.white_can_pass)
}
Created
trap.rs
+384
-0
trap.rs
+384
-0

use std::collections::VecDeque;
use std::sync::Arc;

use rustc_hash::{FxHashMap, FxHashSet};

use crate::chess::bounds::enumerate_positions_in_bound;
use crate::scenario::{CacheMode, CandidateGeneration, DomainLike, LawsLike, Scenario, SearchError, Side, State};
use crate::search::movegen::{is_stalemate_with_laws, legal_black_moves, legal_white_moves};
use crate::search::resources::ResourceTracker;

/// Cache for move generation during trap pruning.
#[derive(Default)]
struct MoveCache {
    black: FxHashMap<State, Arc<[State]>>,
    white: FxHashMap<State, Arc<[State]>>,
}

impl MoveCache {
    fn black_moves<D, L, P>(
        &mut self,
        scn: &Scenario<D, L, P>,
        tracker: &mut ResourceTracker,
        s: &State,
    ) -> Result<Arc<[State]>, SearchError>
    where
        D: DomainLike,
        L: LawsLike,
    {
        let do_cache = matches!(scn.cache_mode, CacheMode::BlackOnly | CacheMode::BothBounded);
        if do_cache {
            if let Some(v) = self.black.get(s) {
                return Ok(v.clone());
            }
        }

        let moves = legal_black_moves(scn, &scn.laws, s, tracker)?;
        let arc: Arc<[State]> = moves.into();

        if do_cache {
            self.evict_to_fit(scn, tracker, 1, arc.len())?;
            tracker.try_reserve_map("cache_black", "black_move_cache", &mut self.black, 1)?;
            tracker.bump_cache_entries("cache_black", 1)?;
            tracker.bump_cached_moves("cache_black", arc.len())?;
            self.black.insert(s.clone(), arc.clone());
        }

        Ok(arc)
    }

    fn white_moves<D, L, P>(
        &mut self,
        scn: &Scenario<D, L, P>,
        tracker: &mut ResourceTracker,
        s: &State,
    ) -> Result<Arc<[State]>, SearchError>
    where
        D: DomainLike,
        L: LawsLike,
    {
        let do_cache = matches!(scn.cache_mode, CacheMode::BothBounded);
        if do_cache {
            if let Some(v) = self.white.get(s) {
                return Ok(v.clone());
            }
        }

        let moves = legal_white_moves(scn, &scn.laws, s, tracker)?;
        let arc: Arc<[State]> = moves.into();

        if do_cache {
            self.evict_to_fit(scn, tracker, 1, arc.len())?;
            tracker.try_reserve_map("cache_white", "white_move_cache", &mut self.white, 1)?;
            tracker.bump_cache_entries("cache_white", 1)?;
            tracker.bump_cached_moves("cache_white", arc.len())?;
            self.white.insert(s.clone(), arc.clone());
        }

        Ok(arc)
    }

    fn evict_to_fit<D, L, P>(
        &mut self,
        scn: &Scenario<D, L, P>,
        tracker: &mut ResourceTracker,
        add_entries: usize,
        add_moves: usize,
    ) -> Result<(), SearchError> {
        let counts = tracker.counts();

        let max_entries = scn.limits.max_cache_entries as u64;
        let max_moves = scn.limits.max_cached_moves as u64;

        let need_entries = add_entries as u64;
        let need_moves = add_moves as u64;

        if need_entries > max_entries {
            return Err(SearchError::LimitExceeded {
                stage: "cache",
                metric: "cache_entries",
                limit: max_entries,
                observed: need_entries,
                counts,
            });
        }
        if need_moves > max_moves {
            return Err(SearchError::LimitExceeded {
                stage: "cache",
                metric: "cached_moves",
                limit: max_moves,
                observed: need_moves,
                counts,
            });
        }

        while tracker.counts().cache_entries + need_entries > max_entries
            || tracker.counts().cached_moves + need_moves > max_moves
        {
            if !self.evict_one(tracker) {
                break;
            }
        }

        let counts = tracker.counts();
        if counts.cache_entries + need_entries > max_entries {
            return Err(SearchError::LimitExceeded {
                stage: "cache",
                metric: "cache_entries",
                limit: max_entries,
                observed: counts.cache_entries + need_entries,
                counts,
            });
        }
        if counts.cached_moves + need_moves > max_moves {
            return Err(SearchError::LimitExceeded {
                stage: "cache",
                metric: "cached_moves",
                limit: max_moves,
                observed: counts.cached_moves + need_moves,
                counts,
            });
        }

        Ok(())
    }

    fn evict_one(&mut self, tracker: &mut ResourceTracker) -> bool {
        if let Some((k, v_len)) = self.black.iter().next().map(|(k, v)| (k.clone(), v.len())) {
            self.black.remove(&k);
            tracker.dec_cache_entries(1);
            tracker.dec_cached_moves(v_len);
            return true;
        }
        if let Some((k, v_len)) = self.white.iter().next().map(|(k, v)| (k.clone(), v.len())) {
            self.white.remove(&k);
            tracker.dec_cache_entries(1);
            tracker.dec_cached_moves(v_len);
            return true;
        }
        false
    }
}

/// Compute the maximal inescapable trap inside the scenario's domain.
///
/// The returned set is a set of **black-to-move** states inside the domain.
pub fn maximal_inescapable_trap<D, L, P>(
    scn: &Scenario<D, L, P>,
) -> Result<FxHashSet<State>, SearchError>
where
    D: DomainLike,
    L: LawsLike,
{
    scn.validate()?;
    let mut tracker = ResourceTracker::new(scn.limits);

    let mut trap = initial_candidate_set(scn, &mut tracker)?;

    let mut cache = MoveCache::default();

    loop {
        tracker.bump_steps("trap_prune_iter", 1)?;

        let mut to_remove: Vec<State> = Vec::new();

        for p in trap.iter() {
            tracker.bump_steps("trap_prune_scan", 1)?;

            // If black has a move to a position from which every white reply exits the current set,
            // then `p` cannot be in an inescapable trap.
            let black_moves = cache.black_moves(scn, &mut tracker, p)?;

            let mut fails = false;
            for after_black in black_moves.iter() {
                let white_moves = cache.white_moves(scn, &mut tracker, after_black)?;
                let has_reply_in_trap = white_moves.iter().any(|q| trap.contains(q));
                if !has_reply_in_trap {
                    fails = true;
                    break;
                }
            }

            if fails {
                to_remove.push(p.clone());
            }
        }

        if to_remove.is_empty() {
            break;
        }

        for p in to_remove {
            trap.remove(&p);
        }
    }

    Ok(trap)
}

/// Compute the maximal *tempo* trap inside an already-computed inescapable trap.
pub fn maximal_tempo_trap<D, L, P>(
    scn: &Scenario<D, L, P>,
    inescapable: &FxHashSet<State>,
) -> Result<FxHashSet<State>, SearchError>
where
    D: DomainLike,
    L: LawsLike,
{
    scn.validate()?;
    crate::search::buchi::tempo_trap_buchi(scn, inescapable)
}

fn initial_candidate_set<D, L, P>(
    scn: &Scenario<D, L, P>,
    tracker: &mut ResourceTracker,
) -> Result<FxHashSet<State>, SearchError>
where
    D: DomainLike,
    L: LawsLike,
{
    let mut trap: FxHashSet<State> = FxHashSet::default();

    match &scn.candidates {
        CandidateGeneration::InLinfBound {
            bound,
            allow_captures,
        } => {
            let positions =
                enumerate_positions_in_bound(&scn.rules.layout, *bound, *allow_captures);

            for pos in positions {
                if !scn.rules.is_legal_position(&pos) {
                    continue;
                }
                let s = State {
                    abs_king: Coord::ORIGIN,
                    pos,
                };
                if !scn.laws.allow_state(&s) {
                    continue;
                }
                if !scn.domain.inside(&s) {
                    continue;
                }
                if scn.remove_stalemates
                    && is_stalemate_with_laws(scn, &scn.laws, &s, tracker)?
                {
                    continue;
                }

                if trap.insert(s) {
                    tracker.bump_states("candidates_in_bound", 1)?;
                }
            }
        }

        CandidateGeneration::FromStates { states } => {
            for s0 in states.iter() {
                if !scn.track_abs_king && s0.abs_king != Coord::ORIGIN {
                    return Err(SearchError::InvalidScenario {
                        reason: "track_abs_king=false requires abs_king==ORIGIN for FromStates"
                            .to_string(),
                    });
                }

                let mut pos = s0.pos.clone();
                pos.canonicalize(&scn.rules.layout);
                if !scn.rules.is_legal_position(&pos) {
                    continue;
                }

                let s = State {
                    abs_king: s0.abs_king,
                    pos,
                };

                if !scn.laws.allow_state(&s) {
                    continue;
                }
                if !scn.domain.inside(&s) {
                    continue;
                }
                if scn.remove_stalemates
                    && is_stalemate_with_laws(scn, &scn.laws, &s, tracker)?
                {
                    continue;
                }

                if trap.insert(s) {
                    tracker.bump_states("candidates_from_states", 1)?;
                }
            }
        }

        CandidateGeneration::ReachableFromStart { max_queue } => {
            if *max_queue == 0 {
                return Err(SearchError::InvalidScenario {
                    reason: "ReachableFromStart requires max_queue > 0".to_string(),
                });
            }

            let mut q: VecDeque<State> = VecDeque::new();

            let mut try_add_b = |b: State,
                                 trap: &mut FxHashSet<State>,
                                 q: &mut VecDeque<State>|
             -> Result<(), SearchError> {
                if !scn.laws.allow_state(&b) {
                    return Ok(());
                }
                if !scn.domain.inside(&b) {
                    return Ok(());
                }
                if scn.remove_stalemates
                    && is_stalemate_with_laws(scn, &scn.laws, &b, tracker)?
                {
                    return Ok(());
                }

                if trap.insert(b.clone()) {
                    tracker.bump_states("candidates_reachable", 1)?;
                    if q.len() >= *max_queue {
                        return Err(SearchError::LimitExceeded {
                            stage: "candidates_reachable",
                            metric: "queue",
                            limit: *max_queue as u64,
                            observed: (q.len() + 1) as u64,
                            counts: tracker.counts(),
                        });
                    }
                    q.push_back(b);
                }
                Ok(())
            };

            match scn.start.to_move {
                Side::Black => {
                    try_add_b(scn.start.state.clone(), &mut trap, &mut q)?;
                }
                Side::White => {
                    let moves =
                        legal_white_moves(scn, &scn.laws, &scn.start.state, tracker)?;
                    for b in moves {
                        try_add_b(b, &mut trap, &mut q)?;
                    }
                }
            }

            while let Some(b) = q.pop_front() {
                tracker.bump_steps("candidates_reachable_scan", 1)?;

                let after_black = legal_black_moves(scn, &scn.laws, &b, tracker)?;
                for w in after_black {
                    let replies = legal_white_moves(scn, &scn.laws, &w, tracker)?;
                    for b2 in replies {
                        try_add_b(b2, &mut trap, &mut q)?;
                    }
                }
            }
        }
    }

    Ok(trap)
}

Edited file
trap.rs
+1
-1

use crate::chess::bounds::enumerate_positions_in_bound;
use crate::core::coord::Coord;
use crate::scenario::{CacheMode, CandidateGeneration, DomainLike, LawsLike, Scenario, SearchError, Side, State};
}

Deleted
buchi.rs
+0
-347
buchi.rs
+0
-347

//! Büchi-game solver for the "tempo trap" refinement.
//!
//! The game graph is bipartite:
//! - Black nodes: black-to-move positions inside an inescapable trap.
//! - White nodes: positions that arise immediately after a legal black king move.
//!
//! White chooses a reply (including optional pass), and we only keep replies that
//! stay inside the inescapable trap.

use rustc_hash::{FxHashMap, FxHashSet};

use crate::chess::rules::Rules;
use crate::core::position::Position;

/// Compute the maximal tempo trap via a Büchi winning-region algorithm.
///
/// Returned set is a subset of `btm_trap` (black-to-move positions).
pub fn tempo_trap_buchi(
    rules: &Rules,
    btm_trap: &FxHashSet<Position>,
    white_can_pass: bool,
) -> FxHashSet<Position> {
    // Index black nodes.
    let b_list: Vec<Position> = btm_trap.iter().cloned().collect();
    let b_len = b_list.len();
    let mut b_index: FxHashMap<Position, usize> = FxHashMap::default();
    for (i, p) in b_list.iter().enumerate() {
        b_index.insert(p.clone(), i);
    }

    // Discover white nodes and black->white edges.
    let mut w_list: Vec<Position> = Vec::new();
    let mut w_index: FxHashMap<Position, usize> = FxHashMap::default();
    let mut bw_succ: Vec<Vec<usize>> = vec![Vec::new(); b_len];

    for (bi, bpos) in b_list.iter().enumerate() {
        let mut succ_w: Vec<usize> = Vec::new();
        for wpos in rules.black_moves(bpos).into_iter() {
            let wi = if let Some(&existing) = w_index.get(&wpos) {
                existing
            } else {
                let idx = w_list.len();
                w_list.push(wpos.clone());
                w_index.insert(wpos.clone(), idx);
                idx
            };
            succ_w.push(wi);
        }
        succ_w.sort_unstable();
        succ_w.dedup();
        bw_succ[bi] = succ_w;
    }

    let w_len = w_list.len();

    // White->black edges (only replies that stay inside btm_trap).
    let mut wb_succ: Vec<Vec<usize>> = vec![Vec::new(); w_len];
    for (wi, wpos) in w_list.iter().enumerate() {
        let mut succ_b: Vec<usize> = Vec::new();
        for bnext in rules.white_moves(wpos, white_can_pass).into_iter() {
            if let Some(&bi) = b_index.get(&bnext) {
                succ_b.push(bi);
            }
        }
        succ_b.sort_unstable();
        succ_b.dedup();
        wb_succ[wi] = succ_b;
    }

    // Acceptance set F: white nodes where passing is possible, i.e. the placement itself is in btm_trap.
    let mut is_accept_w: Vec<bool> = vec![false; w_len];
    for (wi, wpos) in w_list.iter().enumerate() {
        if b_index.contains_key(wpos) {
            is_accept_w[wi] = true;
        }
    }

    // Z is the current candidate winning region (subgame). Initially all nodes.
    let mut in_z_b: Vec<bool> = vec![true; b_len];
    let mut in_z_w: Vec<bool> = vec![true; w_len];

    loop {
        // Y = Attr_white(F) within Z.
        let (in_y_b, in_y_w) = attractor_white(&in_z_b, &in_z_w, &bw_succ, &wb_succ, &is_accept_w);

        // Target for black attractor is Z \ Y.
        let mut target_b: Vec<bool> = vec![false; b_len];
        let mut target_w: Vec<bool> = vec![false; w_len];
        for i in 0..b_len {
            if in_z_b[i] && !in_y_b[i] {
                target_b[i] = true;
            }
        }
        for i in 0..w_len {
            if in_z_w[i] && !in_y_w[i] {
                target_w[i] = true;
            }
        }

        let (in_x_b, in_x_w) =
            attractor_black(&in_z_b, &in_z_w, &bw_succ, &wb_succ, &target_b, &target_w);

        let mut any_removed = false;
        for i in 0..b_len {
            if in_z_b[i] && in_x_b[i] {
                in_z_b[i] = false;
                any_removed = true;
            }
        }
        for i in 0..w_len {
            if in_z_w[i] && in_x_w[i] {
                in_z_w[i] = false;
                any_removed = true;
            }
        }

        if !any_removed {
            break;
        }
    }

    // Return black positions that remain in Z.
    let mut out: FxHashSet<Position> = FxHashSet::default();
    for (i, p) in b_list.into_iter().enumerate() {
        if in_z_b[i] {
            out.insert(p);
        }
    }
    out
}

/// Attractor to the accepting set for White.
///
/// Player 1 = White.
/// - White nodes join the attractor if they have *some* edge into it.
/// - Black nodes join if *all* their edges (within Z) go into it.
///
/// We intentionally require black nodes to have at least one successor inside Z;
/// otherwise the play ends (mate/stalemate) and cannot satisfy an "infinitely often"
/// objective.
fn attractor_white(
    in_z_b: &[bool],
    in_z_w: &[bool],
    bw_succ: &[Vec<usize>],
    wb_succ: &[Vec<usize>],
    is_accept_w: &[bool],
) -> (Vec<bool>, Vec<bool>) {
    let b_len = in_z_b.len();
    let w_len = in_z_w.len();

    let mut in_a_b: Vec<bool> = vec![false; b_len];
    let mut in_a_w: Vec<bool> = vec![false; w_len];

    for wi in 0..w_len {
        if in_z_w[wi] && is_accept_w[wi] {
            in_a_w[wi] = true;
        }
    }

    let mut changed = true;
    while changed {
        changed = false;

        // White nodes: exists succ in A.
        for wi in 0..w_len {
            if !in_z_w[wi] || in_a_w[wi] {
                continue;
            }
            let has_edge = wb_succ[wi].iter().any(|&bi| in_z_b[bi] && in_a_b[bi]);
            if has_edge {
                in_a_w[wi] = true;
                changed = true;
            }
        }

        // Black nodes: all succ in A (and succ non-empty inside Z).
        for bi in 0..b_len {
            if !in_z_b[bi] || in_a_b[bi] {
                continue;
            }
            let mut saw_succ_in_z = false;
            let mut all_in_a = true;
            for &wi in bw_succ[bi].iter() {
                if !in_z_w[wi] {
                    continue;
                }
                saw_succ_in_z = true;
                if !in_a_w[wi] {
                    all_in_a = false;
                    break;
                }
            }
            if saw_succ_in_z && all_in_a {
                in_a_b[bi] = true;
                changed = true;
            }
        }
    }

    (in_a_b, in_a_w)
}

/// Attractor to a target set for Black.
///
/// Player 2 = Black.
/// - Black nodes join the attractor if they have *some* edge into it.
/// - White nodes join if *all* their edges (within Z) go into it.
fn attractor_black(
    in_z_b: &[bool],
    in_z_w: &[bool],
    bw_succ: &[Vec<usize>],
    wb_succ: &[Vec<usize>],
    target_b: &[bool],
    target_w: &[bool],
) -> (Vec<bool>, Vec<bool>) {
    let b_len = in_z_b.len();
    let w_len = in_z_w.len();

    let mut in_a_b: Vec<bool> = vec![false; b_len];
    let mut in_a_w: Vec<bool> = vec![false; w_len];

    // Seed with target.
    for bi in 0..b_len {
        if in_z_b[bi] && target_b[bi] {
            in_a_b[bi] = true;
        }
    }
    for wi in 0..w_len {
        if in_z_w[wi] && target_w[wi] {
            in_a_w[wi] = true;
        }
    }

    let mut changed = true;
    while changed {
        changed = false;

        // Black nodes: exists succ in A.
        for bi in 0..b_len {
            if !in_z_b[bi] || in_a_b[bi] {
                continue;
            }
            let has_edge = bw_succ[bi].iter().any(|&wi| in_z_w[wi] && in_a_w[wi]);
            if has_edge {
                in_a_b[bi] = true;
                changed = true;
            }
        }

        // White nodes: all succ in A (and succ non-empty inside Z).
        for wi in 0..w_len {
            if !in_z_w[wi] || in_a_w[wi] {
                continue;
            }
            let mut saw_succ_in_z = false;
            let mut all_in_a = true;
            for &bi in wb_succ[wi].iter() {
                if !in_z_b[bi] {
                    continue;
                }
                saw_succ_in_z = true;
                if !in_a_b[bi] {
                    all_in_a = false;
                    break;
                }
            }
            if saw_succ_in_z && all_in_a {
                in_a_w[wi] = true;
                changed = true;
            }
        }
    }

    (in_a_b, in_a_w)
}

#[cfg(test)]
mod tests {
    use super::*;

    /// Tiny hand-made Büchi game sanity check.
    ///
    /// Graph:
    ///   B0 -> W0
    ///   B1 -> W1
    ///   W0 -> B0 or B1
    ///   W1 -> B1
    /// Acceptance set: {W0}
    ///
    /// From B0, White can keep going through W0 forever -> winning.
    /// From B1, the play is stuck visiting only W1 -> losing.
    #[test]
    fn buchi_sanity_game() {
        // We'll "fake" the chess layer by directly calling the internal attractor functions.
        // Two black nodes, two white nodes.
        let b_len = 2usize;
        let w_len = 2usize;

        let bw_succ = vec![vec![0usize], vec![1usize]];
        let wb_succ = vec![vec![0usize, 1usize], vec![1usize]];
        let is_accept_w = vec![true, false];

        let mut in_z_b = vec![true; b_len];
        let mut in_z_w = vec![true; w_len];

        loop {
            let (in_y_b, in_y_w) =
                attractor_white(&in_z_b, &in_z_w, &bw_succ, &wb_succ, &is_accept_w);

            let mut target_b = vec![false; b_len];
            let mut target_w = vec![false; w_len];
            for i in 0..b_len {
                if in_z_b[i] && !in_y_b[i] {
                    target_b[i] = true;
                }
            }
            for i in 0..w_len {
                if in_z_w[i] && !in_y_w[i] {
                    target_w[i] = true;
                }
            }

            let (in_x_b, in_x_w) =
                attractor_black(&in_z_b, &in_z_w, &bw_succ, &wb_succ, &target_b, &target_w);

            let mut any_removed = false;
            for i in 0..b_len {
                if in_z_b[i] && in_x_b[i] {
                    in_z_b[i] = false;
                    any_removed = true;
                }
            }
            for i in 0..w_len {
                if in_z_w[i] && in_x_w[i] {
                    in_z_w[i] = false;
                    any_removed = true;
                }
            }

            if !any_removed {
                break;
            }
        }

        assert_eq!(in_z_b, vec![true, false]);
    }
}
Created
buchi.rs
+292
-0
buchi.rs
+292
-0

//! Büchi-game solver for the "tempo trap" refinement.
//!
//! The game graph is bipartite:
//! - Black nodes: black-to-move states inside an inescapable trap.
//! - White nodes: states that arise immediately after a legal black king move.
//!
//! White chooses a reply (including optional pass), and we only keep replies that
//! stay inside the inescapable trap.

use rustc_hash::{FxHashMap, FxHashSet};

use crate::scenario::{DomainLike, LawsLike, Scenario, SearchError, State};
use crate::search::movegen::{legal_black_moves, legal_white_moves};
use crate::search::resources::ResourceTracker;

/// Compute the maximal tempo trap via a Büchi winning-region algorithm.
///
/// Returned set is a subset of `btm_trap` (black-to-move states).
pub fn tempo_trap_buchi<D, L, P>(
    scn: &Scenario<D, L, P>,
    btm_trap: &FxHashSet<State>,
) -> Result<FxHashSet<State>, SearchError>
where
    D: DomainLike,
    L: LawsLike,
{
    let mut tracker = ResourceTracker::new(scn.limits);

    // Index black nodes.
    let b_list: Vec<State> = btm_trap.iter().cloned().collect();
    tracker.bump_states("buchi_black_nodes", b_list.len())?;

    let b_len = b_list.len();
    let mut b_index: FxHashMap<State, usize> = FxHashMap::default();
    tracker.try_reserve_map("buchi_black_index", "b_index", &mut b_index, b_len)?;
    for (i, p) in b_list.iter().enumerate() {
        b_index.insert(p.clone(), i);
    }

    // Discover white nodes and black->white edges.
    let mut w_list: Vec<State> = Vec::new();
    let mut w_index: FxHashMap<State, usize> = FxHashMap::default();
    let mut bw_succ: Vec<Vec<usize>> = vec![Vec::new(); b_len];

    for (bi, bpos) in b_list.iter().enumerate() {
        tracker.bump_steps("buchi_build_bw", 1)?;

        let mut succ_w: Vec<usize> = Vec::new();
        for wpos in legal_black_moves(scn, &scn.laws, bpos, &mut tracker)? {
            let wi = if let Some(&existing) = w_index.get(&wpos) {
                existing
            } else {
                let idx = w_list.len();
                w_list.push(wpos.clone());
                w_index.insert(wpos.clone(), idx);
                tracker.bump_states("buchi_white_nodes", 1)?;
                idx
            };
            succ_w.push(wi);
        }
        succ_w.sort_unstable();
        succ_w.dedup();
        bw_succ[bi] = succ_w;
    }

    let w_len = w_list.len();

    // White->black edges (only replies that stay inside btm_trap).
    let mut wb_succ: Vec<Vec<usize>> = vec![Vec::new(); w_len];
    for (wi, wpos) in w_list.iter().enumerate() {
        tracker.bump_steps("buchi_build_wb", 1)?;

        let mut succ_b: Vec<usize> = Vec::new();
        for bnext in legal_white_moves(scn, &scn.laws, wpos, &mut tracker)? {
            if let Some(&bi) = b_index.get(&bnext) {
                succ_b.push(bi);
            }
        }
        succ_b.sort_unstable();
        succ_b.dedup();
        wb_succ[wi] = succ_b;
    }

    // Acceptance set F: white nodes where passing is possible, i.e. the placement itself is in btm_trap.
    let mut is_accept_w: Vec<bool> = vec![false; w_len];
    for (wi, wpos) in w_list.iter().enumerate() {
        if scn.white_can_pass && scn.laws.allow_pass(wpos) && b_index.contains_key(wpos) {
            is_accept_w[wi] = true;
        }
    }

    // Z is the current candidate winning region (subgame). Initially all nodes.
    let mut in_z_b: Vec<bool> = vec![true; b_len];
    let mut in_z_w: Vec<bool> = vec![true; w_len];

    loop {
        tracker.bump_steps("buchi_iter", 1)?;

        // Y = Attr_white(F) within Z.
        let (in_y_b, in_y_w) = attractor_white(&in_z_b, &in_z_w, &bw_succ, &wb_succ, &is_accept_w);

        // Target for black attractor is Z \ Y.
        let mut target_b: Vec<bool> = vec![false; b_len];
        let mut target_w: Vec<bool> = vec![false; w_len];
        for i in 0..b_len {
            if in_z_b[i] && !in_y_b[i] {
                target_b[i] = true;
            }
        }
        for i in 0..w_len {
            if in_z_w[i] && !in_y_w[i] {
                target_w[i] = true;
            }
        }

        let (in_x_b, in_x_w) =
            attractor_black(&in_z_b, &in_z_w, &bw_succ, &wb_succ, &target_b, &target_w);

        let mut any_removed = false;
        for i in 0..b_len {
            if in_z_b[i] && in_x_b[i] {
                in_z_b[i] = false;
                any_removed = true;
            }
        }
        for i in 0..w_len {
            if in_z_w[i] && in_x_w[i] {
                in_z_w[i] = false;
                any_removed = true;
            }
        }

        if !any_removed {
            break;
        }
    }

    // Return black states that remain in Z.
    let mut out: FxHashSet<State> = FxHashSet::default();
    for (i, p) in b_list.into_iter().enumerate() {
        if in_z_b[i] {
            out.insert(p);
        }
    }

    Ok(out)
}

/// Attractor to the accepting set for White.
///
/// Player 1 = White.
/// - White nodes join the attractor if they have *some* edge into it.
/// - Black nodes join if *all* their edges (within Z) go into it.
///
/// We intentionally require black nodes to have at least one successor inside Z;
/// otherwise the play ends and cannot satisfy an "infinitely often" objective.
fn attractor_white(
    in_z_b: &[bool],
    in_z_w: &[bool],
    bw_succ: &[Vec<usize>],
    wb_succ: &[Vec<usize>],
    is_accept_w: &[bool],
) -> (Vec<bool>, Vec<bool>) {
    let b_len = in_z_b.len();
    let w_len = in_z_w.len();

    let mut in_a_b: Vec<bool> = vec![false; b_len];
    let mut in_a_w: Vec<bool> = vec![false; w_len];

    for wi in 0..w_len {
        if in_z_w[wi] && is_accept_w[wi] {
            in_a_w[wi] = true;
        }
    }

    let mut changed = true;
    while changed {
        changed = false;

        // White nodes: exists succ in A.
        for wi in 0..w_len {
            if !in_z_w[wi] || in_a_w[wi] {
                continue;
            }
            let has_edge = wb_succ[wi].iter().any(|&bi| in_z_b[bi] && in_a_b[bi]);
            if has_edge {
                in_a_w[wi] = true;
                changed = true;
            }
        }

        // Black nodes: all succ in A (and succ non-empty inside Z).
        for bi in 0..b_len {
            if !in_z_b[bi] || in_a_b[bi] {
                continue;
            }
            let mut saw_succ_in_z = false;
            let mut all_in_a = true;
            for &wi in bw_succ[bi].iter() {
                if !in_z_w[wi] {
                    continue;
                }
                saw_succ_in_z = true;
                if !in_a_w[wi] {
                    all_in_a = false;
                    break;
                }
            }
            if saw_succ_in_z && all_in_a {
                in_a_b[bi] = true;
                changed = true;
            }
        }
    }

    (in_a_b, in_a_w)
}

/// Attractor to a target set for Black.
///
/// Player 2 = Black.
/// - Black nodes join the attractor if they have *some* edge into it.
/// - White nodes join if *all* their edges (within Z) go into it.
fn attractor_black(
    in_z_b: &[bool],
    in_z_w: &[bool],
    bw_succ: &[Vec<usize>],
    wb_succ: &[Vec<usize>],
    target_b: &[bool],
    target_w: &[bool],
) -> (Vec<bool>, Vec<bool>) {
    let b_len = in_z_b.len();
    let w_len = in_z_w.len();

    let mut in_a_b: Vec<bool> = vec![false; b_len];
    let mut in_a_w: Vec<bool> = vec![false; w_len];

    // Seed with target.
    for bi in 0..b_len {
        if in_z_b[bi] && target_b[bi] {
            in_a_b[bi] = true;
        }
    }
    for wi in 0..w_len {
        if in_z_w[wi] && target_w[wi] {
            in_a_w[wi] = true;
        }
    }

    let mut changed = true;
    while changed {
        changed = false;

        // Black nodes: exists succ in A.
        for bi in 0..b_len {
            if !in_z_b[bi] || in_a_b[bi] {
                continue;
            }
            let has_edge = bw_succ[bi].iter().any(|&wi| in_z_w[wi] && in_a_w[wi]);
            if has_edge {
                in_a_b[bi] = true;
                changed = true;
            }
        }

        // White nodes: all succ in A (and succ non-empty inside Z).
        for wi in 0..w_len {
            if !in_z_w[wi] || in_a_w[wi] {
                continue;
            }
            let mut saw_succ_in_z = false;
            let mut all_in_a = true;
            for &bi in wb_succ[wi].iter() {
                if !in_z_b[bi] {
                    continue;
                }
                saw_succ_in_z = true;
                if !in_a_b[bi] {
                    all_in_a = false;
                    break;
                }
            }
            if saw_succ_in_z && all_in_a {
                in_a_w[wi] = true;
                changed = true;
            }
        }
    }

    (in_a_b, in_a_w)
}

Deleted
mod.rs
+0
-48
mod.rs
+0
-48

//! Built-in scenarios (compile-time configs).

use crate::chess::config::ScenarioConfig;
use crate::chess::layout::PieceLayout;

/// 3 rooks, bound=2, move_bound=1.
///
/// This is small enough to be used in tests and fast demos.
pub fn three_rooks_bound2_mb1() -> ScenarioConfig {
    ScenarioConfig::new(
        "three_rooks_bound2_mb1",
        2,
        1,
        true,
        true,
        PieceLayout::from_counts(false, 0, 3, 0, 0),
    )
}

/// 2 rooks, bound=7 (used for the "no checkmates" known result).
pub fn two_rooks_bound7() -> ScenarioConfig {
    ScenarioConfig::new(
        "two_rooks_bound7",
        7,
        7,
        true,
        true,
        PieceLayout::from_counts(false, 0, 2, 0, 0),
    )
}

/// Return a config by name.
pub fn by_name(name: &str) -> Option<ScenarioConfig> {
    match name {
        "three_rooks_bound2_mb1" => Some(three_rooks_bound2_mb1()),
        "two_rooks_bound7" => Some(two_rooks_bound7()),
        _ => None,
    }
}

/// Names of all built-in scenarios.
pub fn names() -> &'static [&'static str] {
    &["three_rooks_bound2_mb1", "two_rooks_bound7"]
}

pub fn available_names() -> &'static [&'static str] {
    names()
}
Created
mod.rs
+125
-0
mod.rs
+125
-0

//! Built-in scenarios (compile-time configs).

pub mod nbb;

use crate::chess::layout::PieceLayout;
use crate::chess::rules::Rules;
use crate::core::coord::Coord;
use crate::core::position::{Position, MAX_PIECES};
use crate::core::square::Square;
use crate::scenario::{
    AllDomain, CacheMode, CandidateGeneration, NoLaws, NoPreferences, ResourceLimits, Scenario,
    SearchError, Side, StartState, State,
};

pub type BuiltInScenario = Scenario<AllDomain, NoLaws, NoPreferences>;

fn pos_from_coords(layout: &PieceLayout, coords: &[Coord]) -> Position {
    assert_eq!(layout.piece_count(), coords.len());
    let mut squares = [Square::NONE; MAX_PIECES];
    for (i, c) in coords.iter().copied().enumerate() {
        squares[i] = Square::from_coord(c);
    }
    let mut pos = Position::new(layout.piece_count(), squares);
    pos.canonicalize(layout);
    pos
}

fn demo_limits() -> ResourceLimits {
    ResourceLimits {
        max_states: 1_000_000,
        max_edges: 25_000_000,
        max_cache_entries: 100_000,
        max_cached_moves: 5_000_000,
        max_runtime_steps: 50_000_000,
    }
}

/// 3 rooks, bound=2, move_bound=1.
///
/// This is small enough to be used in tests and fast demos.
pub fn three_rooks_bound2_mb1() -> BuiltInScenario {
    let layout = PieceLayout::from_counts(false, 0, 3, 0, 0);
    let rules = Rules::new(layout.clone(), 1);
    let start_pos = pos_from_coords(
        &layout,
        &[
            Coord::new(2, 2),
            Coord::new(-2, 2),
            Coord::new(2, -2),
        ],
    );

    Scenario {
        name: "three_rooks_bound2_mb1",
        rules,
        white_can_pass: true,
        track_abs_king: false,
        start: StartState {
            to_move: Side::Black,
            state: State::new(Coord::ORIGIN, start_pos),
        },
        candidates: CandidateGeneration::InLinfBound {
            bound: 2,
            allow_captures: true,
        },
        domain: AllDomain,
        laws: NoLaws,
        preferences: NoPreferences,
        limits: demo_limits(),
        cache_mode: CacheMode::BothBounded,
        remove_stalemates: true,
    }
}

/// 2 rooks, bound=7 (used for the "no checkmates" known result).
pub fn two_rooks_bound7() -> BuiltInScenario {
    let layout = PieceLayout::from_counts(false, 0, 2, 0, 0);
    let rules = Rules::new(layout.clone(), 7);
    let start_pos = pos_from_coords(&layout, &[Coord::new(1, 3), Coord::new(-2, -5)]);

    Scenario {
        name: "two_rooks_bound7",
        rules,
        white_can_pass: true,
        track_abs_king: false,
        start: StartState {
            to_move: Side::Black,
            state: State::new(Coord::ORIGIN, start_pos),
        },
        candidates: CandidateGeneration::InLinfBound {
            bound: 7,
            allow_captures: true,
        },
        domain: AllDomain,
        laws: NoLaws,
        preferences: NoPreferences,
        limits: demo_limits(),
        cache_mode: CacheMode::BothBounded,
        remove_stalemates: true,
    }
}

pub fn nbb20_from_file() -> Result<BuiltInScenario, SearchError> {
    nbb::nbb20_from_file()
}

/// Return a config by name.
pub fn by_name(name: &str) -> Result<Option<BuiltInScenario>, SearchError> {
    match name {
        "three_rooks_bound2_mb1" => Ok(Some(three_rooks_bound2_mb1())),
        "two_rooks_bound7" => Ok(Some(two_rooks_bound7())),
        "nbb20_from_file" => Ok(Some(nbb20_from_file()?)),
        _ => Ok(None),
    }
}

/// Names of all built-in scenarios.
pub fn names() -> &'static [&'static str] {
    &["three_rooks_bound2_mb1", "two_rooks_bound7", "nbb20_from_file"]
}

pub fn available_names() -> &'static [&'static str] {
    names()
}

Created
nbb.rs
+152
-0
nbb.rs
+152
-0

use std::path::{Path, PathBuf};

use crate::chess::layout::PieceLayout;
use crate::chess::rules::Rules;
use crate::core::coord::Coord;
use crate::core::position::{Position, MAX_PIECES};
use crate::core::square::Square;
use crate::scenario::{
    AllDomain, CacheMode, CandidateGeneration, NoLaws, NoPreferences, ResourceLimits, Scenario,
    SearchError, Side, StartState, State,
};

pub fn nbb20_from_file() -> Result<Scenario<AllDomain, NoLaws, NoPreferences>, SearchError> {
    let path = default_trap_file_path();

    let layout = PieceLayout::from_counts(false, 0, 0, 2, 1); // B B N
    let rules = Rules::new(layout.clone(), 23);

    let states = parse_k_nbb_trap_file(&path, &layout, &rules)?;

    let start = states
        .first()
        .cloned()
        .ok_or_else(|| SearchError::InvalidScenario {
            reason: "NBB trap file parsed to an empty set".to_string(),
        })?;

    Ok(Scenario {
        name: "nbb20_from_file",
        rules,
        white_can_pass: true,
        track_abs_king: true,
        start: StartState {
            to_move: Side::Black,
            state: start,
        },
        candidates: CandidateGeneration::FromStates { states },
        domain: AllDomain,
        laws: NoLaws,
        preferences: NoPreferences,
        limits: nbb_limits(),
        cache_mode: CacheMode::BlackOnly,
        remove_stalemates: true,
    })
}

fn default_trap_file_path() -> PathBuf {
    PathBuf::from(env!("CARGO_MANIFEST_DIR"))
        .join("BBN_script")
        .join("InfiniteChessEndgameScripts")
        .join("kNBB_20_3_2.5_23.txt")
}

fn nbb_limits() -> ResourceLimits {
    ResourceLimits {
        max_states: 500_000,
        max_edges: 200_000_000,
        max_cache_entries: 250_000,
        max_cached_moves: 3_000_000,
        max_runtime_steps: 500_000_000,
    }
}

fn parse_k_nbb_trap_file(
    path: &Path,
    layout: &PieceLayout,
    rules: &Rules,
) -> Result<Vec<State>, SearchError> {
    let bytes = std::fs::read(path).map_err(|e| SearchError::Io {
        stage: "nbb_read",
        path: path.display().to_string(),
        error: e.to_string(),
    })?;

    // Streaming-ish parser: scan all integers and process in 8-tuples:
    // (king_x, king_y, knight_x, knight_y, bishop1_x, bishop1_y, bishop2_x, bishop2_y)
    let mut out: Vec<State> = Vec::new();
    let mut buf = [0i32; 8];
    let mut buf_len = 0usize;

    let mut in_num = false;
    let mut sign: i32 = 1;
    let mut acc: i32 = 0;

    let mut push_int = |x: i32, out: &mut Vec<State>, buf: &mut [i32; 8], buf_len: &mut usize| {
        buf[*buf_len] = x;
        *buf_len += 1;
        if *buf_len == 8 {
            let kx = buf[0];
            let ky = buf[1];
            let nx = buf[2];
            let ny = buf[3];
            let b1x = buf[4];
            let b1y = buf[5];
            let b2x = buf[6];
            let b2y = buf[7];

            let abs_king = Coord::new(kx, ky);
            let n_rel = Coord::new(nx - kx, ny - ky);
            let b1_rel = Coord::new(b1x - kx, b1y - ky);
            let b2_rel = Coord::new(b2x - kx, b2y - ky);

            let mut squares = [Square::NONE; MAX_PIECES];
            // Layout is B,B,N.
            squares[0] = Square::from_coord(b1_rel);
            squares[1] = Square::from_coord(b2_rel);
            squares[2] = Square::from_coord(n_rel);

            let mut pos = Position::new(layout.piece_count(), squares);
            pos.canonicalize(layout);

            if rules.is_legal_position(&pos) {
                out.push(State::new(abs_king, pos));
            }

            *buf_len = 0;
        }
    };

    for &b in bytes.iter() {
        match b {
            b'-' => {
                in_num = true;
                sign = -1;
                acc = 0;
            }
            b'0'..=b'9' => {
                if !in_num {
                    in_num = true;
                    sign = 1;
                    acc = 0;
                }
                acc = acc.saturating_mul(10).saturating_add((b - b'0') as i32);
            }
            _ => {
                if in_num {
                    push_int(sign * acc, &mut out, &mut buf, &mut buf_len);
                    in_num = false;
                    sign = 1;
                    acc = 0;
                }
            }
        }
    }

    if in_num {
        push_int(sign * acc, &mut out, &mut buf, &mut buf_len);
    }

    Ok(out)
}

Deleted
config.rs
+0
-64
config.rs
+0
-64

use crate::chess::layout::PieceLayout;
use crate::chess::piece::PieceKind;
use crate::chess::rules::Rules;

/// Scenario configuration (pure Rust, no JSON).
#[derive(Debug, Clone)]
pub struct ScenarioConfig {
    pub name: &'static str,

    /// L∞ bound for enumerating *candidate* black-to-move positions.
    pub bound: i32,

    /// Maximum distance a sliding piece may move in a single white move.
    pub move_bound: i32,

    /// Whether White may pass (gain tempo) on her move.
    pub white_can_pass: bool,

    /// Remove stalemates from the candidate set (recommended for trap search).
    pub remove_stalemates: bool,

    pub layout: PieceLayout,
}

impl ScenarioConfig {
    pub fn new(
        name: &'static str,
        bound: i32,
        move_bound: i32,
        white_can_pass: bool,
        remove_stalemates: bool,
        layout: PieceLayout,
    ) -> Self {
        Self {
            name,
            bound,
            move_bound,
            white_can_pass,
            remove_stalemates,
            layout,
        }
    }

    pub fn piece_summary(&self) -> String {
        // compact, deterministic order
        let mut counts: Vec<(PieceKind, usize)> = Vec::new();
        for k in self.layout.kinds() {
            if let Some((_, c)) = counts.last_mut().filter(|(kind, _)| *kind == *k) {
                *c += 1;
            } else {
                counts.push((*k, 1));
            }
        }
        counts
            .into_iter()
            .map(|(k, c)| format!("{:?}x{}", k, c))
            .collect::<Vec<_>>()
            .join(", ")
    }

    pub fn rules(&self) -> Rules {
        Rules::new(self.layout.clone(), self.move_bound)
    }
}
Edited file
mod.rs
+0
-1

pub mod bounds;
pub mod config;
pub mod layout;
Edited file
trap_search.rs
+46
-14

    let scenario_name = &args[1];
    let cfg = scenarios::by_name(scenario_name).unwrap_or_else(|| {
        eprintln!(
            "Unknown scenario: {scenario_name}\n\nAvailable scenarios:\n  - {}",
            scenarios::available_names().join("\n  - ")
        );
    let scn = match scenarios::by_name(scenario_name) {
        Ok(Some(s)) => s,
        Ok(None) => {
            eprintln!(
                "Unknown scenario: {scenario_name}\n\nAvailable scenarios:\n  - {}",
                scenarios::available_names().join("\n  - ")
            );
            std::process::exit(2);
        }
        Err(e) => {
            eprintln!("Failed to load scenario {scenario_name}: {e}");
            std::process::exit(1);
        }
    };

    if let Err(e) = scn.validate() {
        eprintln!("Invalid scenario {scenario_name}: {e}");
        std::process::exit(2);
    });
    }

    println!("Scenario: {}", cfg.name);
    println!("  pieces: {:?}", cfg.layout.kinds());
    println!("  bound: {}", cfg.bound);
    println!("  move_bound: {}", cfg.move_bound);
    println!("  white_can_pass: {}", cfg.white_can_pass);
    println!("  remove_stalemates: {}", cfg.remove_stalemates);
    println!("Scenario: {}", scn.name);
    println!("  pieces: {:?}", scn.rules.layout.kinds());
    println!("  move_bound: {}", scn.rules.move_bound);
    println!("  white_can_pass: {}", scn.white_can_pass);
    println!("  remove_stalemates: {}", scn.remove_stalemates);
    println!("  candidates: {:?}", scn.candidates);
    println!("  track_abs_king: {}", scn.track_abs_king);
    println!("  cache_mode: {:?}", scn.cache_mode);
    println!("  limits:");
    println!("    max_states: {}", scn.limits.max_states);
    println!("    max_edges: {}", scn.limits.max_edges);
    println!("    max_cache_entries: {}", scn.limits.max_cache_entries);
    println!("    max_cached_moves: {}", scn.limits.max_cached_moves);
    println!("    max_runtime_steps: {}", scn.limits.max_runtime_steps);

    let trap = maximal_inescapable_trap(&cfg);
    let trap = match maximal_inescapable_trap(&scn) {
        Ok(t) => t,
        Err(e) => {
            eprintln!("Trap search failed: {e}");
            std::process::exit(1);
        }
    };
    println!("inescapable trap size: {}", trap.len());

    let tempo = maximal_tempo_trap(&cfg, &trap);
    let tempo = match maximal_tempo_trap(&scn, &trap) {
        Ok(t) => t,
        Err(e) => {
            eprintln!("Tempo trap search failed: {e}");
            std::process::exit(1);
        }
    };
    println!("tempo trap size: {}", tempo.len());
Edited file
mate_search.rs
+30
-13

    let scenario_name = &args[1];
    let cfg = scenarios::by_name(scenario_name).unwrap_or_else(|| {
        eprintln!(
            "Unknown scenario: {scenario_name}\n\nAvailable scenarios:\n  - {}",
            scenarios::available_names().join("\n  - ")
        );
        std::process::exit(2);
    });
    let scn = match scenarios::by_name(scenario_name) {
        Ok(Some(s)) => s,
        Ok(None) => {
            eprintln!(
                "Unknown scenario: {scenario_name}\n\nAvailable scenarios:\n  - {}",
                scenarios::available_names().join("\n  - ")
            );
            std::process::exit(2);
        }
        Err(e) => {
            eprintln!("Failed to load scenario {scenario_name}: {e}");
            std::process::exit(1);
        }
    };

    let rules = cfg.rules();
    let mates = count_checkmates_in_bound(&rules, cfg.bound);
    let bound = match scn.candidates {
        infinite_chess::scenario::CandidateGeneration::InLinfBound { bound, .. } => bound,
        _ => {
            eprintln!("Scenario {scenario_name} does not define an L∞ bound for mate enumeration.");
            std::process::exit(2);
        }
    };

    println!("Scenario: {}", cfg.name);
    println!("  pieces: {:?}", cfg.layout.kinds());
    println!("  bound: {}", cfg.bound);
    println!("  checkmates in slice (infinite-board legality): {}", mates);
    let mates = count_checkmates_in_bound(&scn.rules, bound);

    println!("Scenario: {}", scn.name);
    println!("  pieces: {:?}", scn.rules.layout.kinds());
    println!("  bound: {}", bound);
    println!(
        "  checkmates in slice (infinite-board legality): {}",
        mates
    );
}
Explored 1 file, 1 search
Searched for chess::config|ScenarioConfig in .
Read known_results.rs
Edited file
known_results.rs
+17
-26

use infinite_chess::chess::config::ScenarioConfig;
use infinite_chess::chess::layout::PieceLayout;
use infinite_chess::chess::rules::Rules;
use infinite_chess::core::coord::Coord;
use infinite_chess::scenario::State;
use infinite_chess::search::mates::count_checkmates_in_bound;
use infinite_chess::search::trap::{maximal_inescapable_trap, maximal_tempo_trap};
use infinite_chess::scenarios;

fn inescapable_trap_size_for_three_rooks_bound2_mb1_is_169() {
    let cfg = ScenarioConfig::new(
        "test_3rooks",
        2,
        1,
        true,
        true,
        PieceLayout::from_counts(false, 0, 3, 0, 0),
    );
    let scn = scenarios::three_rooks_bound2_mb1();

    let trap = maximal_inescapable_trap(&cfg);
    let trap = maximal_inescapable_trap(&scn).unwrap();
    assert_eq!(trap.len(), 169);
    // every legal black move has some white reply that stays in the trap.
    let rules = cfg.rules();
    let rules = &scn.rules;
    for p in &trap {
        for after_black in rules.black_moves(p) {
            let replies = rules.white_moves(&after_black, cfg.white_can_pass);
            assert!(replies.iter().any(|r| trap.contains(r)));
        for after_black_pos in rules.black_moves(&p.pos) {
            let after_black = State::new(Coord::ORIGIN, after_black_pos);
            let replies = rules.white_moves(&after_black.pos, scn.white_can_pass);
            assert!(replies
                .into_iter()
                .map(|pos| State::new(Coord::ORIGIN, pos))
                .any(|r| trap.contains(&r)));
        }
fn tempo_trap_size_for_three_rooks_bound2_mb1_is_113_and_excludes_mates() {
    let cfg = ScenarioConfig::new(
        "test_3rooks",
        2,
        1,
        true,
        true,
        PieceLayout::from_counts(false, 0, 3, 0, 0),
    );
    let scn = scenarios::three_rooks_bound2_mb1();

    let trap = maximal_inescapable_trap(&cfg);
    let tempo = maximal_tempo_trap(&cfg, &trap);
    let trap = maximal_inescapable_trap(&scn).unwrap();
    let tempo = maximal_tempo_trap(&scn, &trap).unwrap();

    // Büchi winning set.
    let rules = cfg.rules();
    for p in &tempo {
        assert!(!rules.is_checkmate(p));
        assert!(!scn.rules.is_checkmate(&p.pos));
    }
Created
laws.rs
+116
-0
laws.rs
+116
-0

use infinite_chess::chess::layout::PieceLayout;
use infinite_chess::chess::rules::Rules;
use infinite_chess::core::coord::Coord;
use infinite_chess::core::position::{Position, MAX_PIECES};
use infinite_chess::core::square::Square;
use infinite_chess::scenario::{
    AllDomain, CacheMode, CandidateGeneration, LawsLike, NoPreferences, ResourceLimits, Scenario,
    Side, StartState, State,
};
use infinite_chess::search::movegen::{legal_black_moves, legal_white_moves};
use infinite_chess::search::resources::ResourceTracker;

#[derive(Debug, Clone, Copy)]
struct NoCapturesLaws;

impl LawsLike for NoCapturesLaws {
    fn allow_black_move(&self, from: &State, _to: &State, delta: Coord) -> bool {
        let dst = Square::from_coord(delta);
        !from.pos.squares().iter().any(|&sq| !sq.is_none() && sq == dst)
    }
}

#[derive(Debug, Clone, Copy)]
struct PassIfAnyPieceOnPositiveX;

impl LawsLike for PassIfAnyPieceOnPositiveX {
    fn allow_pass(&self, s: &State) -> bool {
        s.pos.iter_present().any(|(_, sq)| sq.coord().x > 0)
    }
}

fn one_rook_pos(c: Coord) -> Position {
    let layout = PieceLayout::from_counts(false, 0, 1, 0, 0);
    let mut squares = [Square::NONE; MAX_PIECES];
    squares[0] = Square::from_coord(c);
    let mut pos = Position::new(layout.piece_count(), squares);
    pos.canonicalize(&layout);
    pos
}

#[test]
fn law_can_forbid_black_capture() {
    let layout = PieceLayout::from_counts(false, 0, 1, 0, 0);
    let rules = Rules::new(layout, 1);
    let start = State::new(Coord::ORIGIN, one_rook_pos(Coord::new(1, 0)));

    let scn_allow = Scenario {
        name: "allow_capture",
        rules: rules.clone(),
        white_can_pass: true,
        track_abs_king: false,
        start: StartState {
            to_move: Side::Black,
            state: start.clone(),
        },
        candidates: CandidateGeneration::FromStates {
            states: vec![start.clone()],
        },
        domain: AllDomain,
        laws: infinite_chess::scenario::NoLaws,
        preferences: NoPreferences,
        limits: ResourceLimits::default(),
        cache_mode: CacheMode::None,
        remove_stalemates: false,
    };

    let mut tracker = ResourceTracker::new(scn_allow.limits);
    let moves = legal_black_moves(&scn_allow, &scn_allow.laws, &start, &mut tracker).unwrap();
    assert!(moves.iter().any(|m| m.pos.square(0).is_none()));

    let scn_forbid = Scenario {
        laws: NoCapturesLaws,
        ..scn_allow
    };

    let mut tracker = ResourceTracker::new(scn_forbid.limits);
    let moves = legal_black_moves(&scn_forbid, &scn_forbid.laws, &start, &mut tracker).unwrap();
    assert!(moves.iter().all(|m| !m.pos.square(0).is_none()));
}

#[test]
fn pass_can_be_controlled_by_law_predicate() {
    let layout = PieceLayout::from_counts(false, 0, 1, 0, 0);
    let rules = Rules::new(layout, 1);

    let base = |state: State| Scenario {
        name: "pass_predicate",
        rules: rules.clone(),
        white_can_pass: true,
        track_abs_king: false,
        start: StartState {
            to_move: Side::White,
            state: state.clone(),
        },
        candidates: CandidateGeneration::FromStates { states: vec![state] },
        domain: AllDomain,
        laws: PassIfAnyPieceOnPositiveX,
        preferences: NoPreferences,
        limits: ResourceLimits::default(),
        cache_mode: CacheMode::None,
        remove_stalemates: false,
    };

    let s_pos = State::new(Coord::ORIGIN, one_rook_pos(Coord::new(1, 0)));
    let scn_pos = base(s_pos.clone());
    let mut tracker = ResourceTracker::new(scn_pos.limits);
    let moves = legal_white_moves(&scn_pos, &scn_pos.laws, &s_pos, &mut tracker).unwrap();
    assert!(moves.iter().any(|m| m == &s_pos));

    let s_neg = State::new(Coord::ORIGIN, one_rook_pos(Coord::new(-1, 0)));
    let scn_neg = base(s_neg.clone());
    let mut tracker = ResourceTracker::new(scn_neg.limits);
    let moves = legal_white_moves(&scn_neg, &scn_neg.laws, &s_neg, &mut tracker).unwrap();
    assert!(moves.iter().all(|m| m != &s_neg));
}

Created
domain_semantics.rs
+105
-0
domain_semantics.rs
+105
-0

use infinite_chess::chess::layout::PieceLayout;
use infinite_chess::chess::rules::Rules;
use infinite_chess::core::coord::Coord;
use infinite_chess::core::position::{Position, MAX_PIECES};
use infinite_chess::core::square::Square;
use infinite_chess::scenario::{
    CacheMode, CandidateGeneration, DomainLike, LawsLike, NoPreferences, ResourceLimits, Scenario,
    Side, StartState, State,
};
use infinite_chess::search::trap::maximal_inescapable_trap;

#[derive(Debug, Clone, Copy)]
struct OnlyBlackDelta(Coord);

impl LawsLike for OnlyBlackDelta {
    fn allow_black_move(&self, _from: &State, _to: &State, delta: Coord) -> bool {
        delta == self.0
    }
}

#[derive(Debug, Clone, Copy)]
struct RookAt(Coord);

impl DomainLike for RookAt {
    fn inside(&self, s: &State) -> bool {
        s.pos.square(0) == Square::from_coord(self.0)
    }
}

fn rook_pos(c: Coord) -> Position {
    let layout = PieceLayout::from_counts(false, 0, 1, 0, 0);
    let mut squares = [Square::NONE; MAX_PIECES];
    squares[0] = Square::from_coord(c);
    let mut pos = Position::new(layout.piece_count(), squares);
    pos.canonicalize(&layout);
    pos
}

#[test]
fn leaving_domain_is_allowed_if_white_can_return_immediately() {
    // Inside domain = rook at (2,1).
    // Black is forced to play delta=(1,0), which shifts the rook out to (1,1).
    // White can then move the rook back to (2,1) in one step.
    let layout = PieceLayout::from_counts(false, 0, 1, 0, 0);
    let rules = Rules::new(layout, 1);

    let inside = State::new(Coord::ORIGIN, rook_pos(Coord::new(2, 1)));
    let scn = Scenario {
        name: "domain_return_ok",
        rules,
        white_can_pass: false,
        track_abs_king: false,
        start: StartState {
            to_move: Side::Black,
            state: inside.clone(),
        },
        candidates: CandidateGeneration::FromStates {
            states: vec![inside.clone()],
        },
        domain: RookAt(Coord::new(2, 1)),
        laws: OnlyBlackDelta(Coord::new(1, 0)),
        preferences: NoPreferences,
        limits: ResourceLimits::default(),
        cache_mode: CacheMode::None,
        remove_stalemates: false,
    };

    let trap = maximal_inescapable_trap(&scn).unwrap();
    assert!(trap.contains(&inside));
}

#[test]
fn leaving_domain_is_escape_if_white_cannot_return() {
    // Inside domain = rook at (1,0).
    // Black is forced to play delta=(1,0), capturing the rook.
    // White cannot return to the inside state.
    let layout = PieceLayout::from_counts(false, 0, 1, 0, 0);
    let rules = Rules::new(layout, 1);

    let inside = State::new(Coord::ORIGIN, rook_pos(Coord::new(1, 0)));
    let scn = Scenario {
        name: "domain_escape",
        rules,
        white_can_pass: false,
        track_abs_king: false,
        start: StartState {
            to_move: Side::Black,
            state: inside.clone(),
        },
        candidates: CandidateGeneration::FromStates {
            states: vec![inside.clone()],
        },
        domain: RookAt(Coord::new(1, 0)),
        laws: OnlyBlackDelta(Coord::new(1, 0)),
        preferences: NoPreferences,
        limits: ResourceLimits::default(),
        cache_mode: CacheMode::None,
        remove_stalemates: false,
    };

    let trap = maximal_inescapable_trap(&scn).unwrap();
    assert!(!trap.contains(&inside));
    assert!(trap.is_empty());
}

Created
mate_nonwall.rs
+78
-0
mate_nonwall.rs
+78
-0

use infinite_chess::chess::layout::PieceLayout;
use infinite_chess::chess::rules::Rules;
use infinite_chess::core::coord::{Coord, KING_STEPS};
use infinite_chess::core::position::{Position, MAX_PIECES};
use infinite_chess::core::square::Square;
use infinite_chess::scenario::{
    AllDomain, CacheMode, CandidateGeneration, NoLaws, NoPreferences, ResourceLimits, Scenario,
    Side, StartState, State,
};
use infinite_chess::search::movegen::{is_checkmate_with_laws, legal_black_moves};
use infinite_chess::search::resources::ResourceTracker;

#[test]
fn mate_logic_does_not_treat_enumeration_bound_as_a_wall() {
    // Construct a position inside bound=2 where Black is in check and the only legal king escape
    // shifts some pieces outside the bound. Mate logic must still see that escape as legal.
    //
    // Pieces:
    // - Rook at (0,2) gives check along the file.
    // - Bishops arranged to attack every king move except (1,0).
    // - Additional bishops sit at x=-2 so that after delta=(1,0) they shift to x=-3 (outside bound=2).
    let bound = 2;
    let layout = PieceLayout::from_counts(false, 0, 1, 3, 0); // R B B B
    let rules = Rules::new(layout.clone(), 1);

    let mut squares = [Square::NONE; MAX_PIECES];
    squares[0] = Square::from_coord(Coord::new(0, 2)); // rook
    squares[1] = Square::from_coord(Coord::new(-2, 2));
    squares[2] = Square::from_coord(Coord::new(-2, -2));
    squares[3] = Square::from_coord(Coord::new(-2, 1));

    let mut pos = Position::new(layout.piece_count(), squares);
    pos.canonicalize(&layout);
    let state = State::new(Coord::ORIGIN, pos);

    assert!(rules.is_attacked(Coord::ORIGIN, &state.pos));

    let scn = Scenario {
        name: "mate_nonwall",
        rules,
        white_can_pass: false,
        track_abs_king: false,
        start: StartState {
            to_move: Side::Black,
            state: state.clone(),
        },
        candidates: CandidateGeneration::InLinfBound {
            bound,
            allow_captures: false,
        },
        domain: AllDomain,
        laws: NoLaws,
        preferences: NoPreferences,
        limits: ResourceLimits::default(),
        cache_mode: CacheMode::None,
        remove_stalemates: false,
    };

    let mut tracker = ResourceTracker::new(scn.limits);
    assert!(!is_checkmate_with_laws(&scn, &scn.laws, &state, &mut tracker).unwrap());

    let moves = legal_black_moves(&scn, &scn.laws, &state, &mut tracker).unwrap();
    assert!(!moves.is_empty());

    for m in moves {
        // The escape move must be allowed even if it shifts pieces outside the enumeration bound.
        let any_outside = m
            .pos
            .squares()
            .iter()
            .any(|&sq| !sq.is_none() && !sq.coord().in_linf_bound(bound));
        assert!(any_outside);
    }

    // Sanity: the intended escape is delta=(1,0).
    assert!(KING_STEPS.contains(&Coord::new(1, 0)));
}

Created
nbb20.rs
+21
-0
nbb20.rs
+21
-0

use infinite_chess::scenarios;
use infinite_chess::search::trap::{maximal_inescapable_trap, maximal_tempo_trap};

/// This test is intentionally ignored by default:
/// it loads a ~8.5MB reference trap set and then runs the fixed-point pruning algorithm,
/// which can be slow and memory-hungry.
///
/// Run with:
/// `cargo test --release -- --ignored nbb20_from_file_has_nonempty_trap_sets`
#[test]
#[ignore]
fn nbb20_from_file_has_nonempty_trap_sets() {
    let scn = scenarios::nbb20_from_file().expect("failed to load NBB scenario");

    let trap = maximal_inescapable_trap(&scn).expect("trap computation failed");
    assert!(!trap.is_empty());

    let tempo = maximal_tempo_trap(&scn, &trap).expect("tempo trap computation failed");
    assert!(!tempo.is_empty());
}

Explored 1 search
Searched for chess::config|ScenarioConfig in src
Ran command for 9s
$ cargo check

    Checking infinite_chess v0.1.0 (/home/hervay_bence_gmail_com/infinite_chess)
error[E0599]: the method `validate` exists for reference `&Scenario<D, L, P>`, but its trait bounds were not satisfied
   --> src/search/trap.rs:174:9
    |
174 |     scn.validate()?;
    |         ^^^^^^^^ method cannot be called on `&Scenario<D, L, P>` due to unsatisfied trait bounds
    |
note: trait bound `P: PreferencesLike` was not satisfied
   --> src/scenario/mod.rs:217:37
    |
217 | impl<D: DomainLike, L: LawsLike, P: PreferencesLike> Scenario<D, L, P> {
    |                                     ^^^^^^^^^^^^^^^  -----------------
    |                                     |
    |                                     unsatisfied trait bound introduced here
help: consider restricting the type parameter to satisfy the trait bound
    |
172 |     L: LawsLike, P: PreferencesLike
    |                  ++++++++++++++++++

error[E0599]: the method `validate` exists for reference `&Scenario<D, L, P>`, but its trait bounds were not satisfied
   --> src/search/trap.rs:229:9
    |
229 |     scn.validate()?;
    |         ^^^^^^^^ method cannot be called on `&Scenario<D, L, P>` due to unsatisfied trait bounds
    |
note: trait bound `P: PreferencesLike` was not satisfied
   --> src/scenario/mod.rs:217:37
    |
217 | impl<D: DomainLike, L: LawsLike, P: PreferencesLike> Scenario<D, L, P> {
    |                                     ^^^^^^^^^^^^^^^  -----------------
    |                                     |
    |                                     unsatisfied trait bound introduced here
help: consider restricting the type parameter to satisfy the trait bound
    |
227 |     L: LawsLike, P: PreferencesLike
    |                  ++++++++++++++++++

warning: variable does not need to be mutable
  --> src/scenarios/nbb.rs:85:9
   |
85 |     let mut push_int = |x: i32, out: &mut Vec<State>, buf: &mut [i32; 8], buf_len: &mut usize| {
   |         ----^^^^^^^^
   |         |
   |         help: remove this `mut`
   |
   = note: `#[warn(unused_mut)]` (part of `#[warn(unused)]`) on by default

error[E0501]: cannot borrow `*tracker` as mutable because previous closure requires unique access
   --> src/search/trap.rs:362:77
    |
324 |               let mut try_add_b = |b: State,
    |  _________________________________-
325 | |                                  trap: &mut FxHashSet<State>,
326 | |                                  q: &mut VecDeque<State>|
327 | |              -> Result<(), SearchError> {
    | |_______________________________________- closure construction occurs here
...
335 |                       && is_stalemate_with_laws(scn, &scn.laws, &b, tracker)?
    |                                                                     ------- first borrow occurs due to use of `*tracker` in closure
...
362 |                           legal_white_moves(scn, &scn.laws, &scn.start.state, tracker)?;
    |                                                                               ^^^^^^^ second borrow occurs here
363 |                       for b in moves {
364 |                           try_add_b(b, &mut trap, &mut q)?;
    |                           --------- first borrow later used here

error[E0501]: cannot borrow `*tracker` as mutable because previous closure requires unique access
   --> src/search/trap.rs:370:17
    |
324 |               let mut try_add_b = |b: State,
    |  _________________________________-
325 | |                                  trap: &mut FxHashSet<State>,
326 | |                                  q: &mut VecDeque<State>|
327 | |              -> Result<(), SearchError> {
    | |_______________________________________- closure construction occurs here
...
335 |                       && is_stalemate_with_laws(scn, &scn.laws, &b, tracker)?
    |                                                                     ------- first borrow occurs due to use of `*tracker` in closure
...
370 |                   tracker.bump_steps("candidates_reachable_scan", 1)?;
    |                   ^^^^^^^ second borrow occurs here
...
376 |                           try_add_b(b2, &mut trap, &mut q)?;
    |                           --------- first borrow later used here

error[E0501]: cannot borrow `*tracker` as mutable because previous closure requires unique access
   --> src/search/trap.rs:372:73
    |
324 |               let mut try_add_b = |b: State,
    |  _________________________________-
325 | |                                  trap: &mut FxHashSet<State>,
326 | |                                  q: &mut VecDeque<State>|
327 | |              -> Result<(), SearchError> {
    | |_______________________________________- closure construction occurs here
...
335 |                       && is_stalemate_with_laws(scn, &scn.laws, &b, tracker)?
    |                                                                     ------- first borrow occurs due to use of `*tracker` in closure
...
372 |                   let after_black = legal_black_moves(scn, &scn.laws, &b, tracker)?;
    |                                                                           ^^^^^^^ second borrow occurs here
...
376 |                           try_add_b(b2, &mut trap, &mut q)?;
    |                           --------- first borrow later used here

error[E0501]: cannot borrow `*tracker` as mutable because previous closure requires unique access
   --> src/search/trap.rs:374:73
    |
324 |               let mut try_add_b = |b: State,
    |  _________________________________-
325 | |                                  trap: &mut FxHashSet<State>,
326 | |                                  q: &mut VecDeque<State>|
327 | |              -> Result<(), SearchError> {
    | |_______________________________________- closure construction occurs here
...
335 |                       && is_stalemate_with_laws(scn, &scn.laws, &b, tracker)?
    |                                                                     ------- first borrow occurs due to use of `*tracker` in closure
...
374 |                       let replies = legal_white_moves(scn, &scn.laws, &w, tracker)?;
    |                                                                           ^^^^^^^ second borrow occurs here
375 |                       for b2 in replies {
376 |                           try_add_b(b2, &mut trap, &mut q)?;
    |                           --------- first borrow later used here

Some errors have detailed explanations: E0501, E0599.
For more information about an error, try `rustc --explain E0501`.
warning: `infinite_chess` (lib) generated 1 warning
error: could not compile `infinite_chess` (lib) due to 6 previous errors; 1 warning emitted
    Checking infinite_chess v0.1.0 (/home/hervay_bence_gmail_com/infinite_chess)
error[E0599]: the method `validate` exists for reference `&Scenario<D, L, P>`, but its trait bounds were not satisfied
   --> src/search/trap.rs:174:9
    |
174 |     scn.validate()?;
    |         ^^^^^^^^ method cannot be called on `&Scenario<D, L, P>` due to unsatisfied trait bounds
    |
note: trait bound `P: PreferencesLike` was not satisfied
   --> src/scenario/mod.rs:217:37
    |
217 | impl<D: DomainLike, L: LawsLike, P: PreferencesLike> Scenario<D, L, P> {
    |                                     ^^^^^^^^^^^^^^^  -----------------
    |                                     |
    |                                     unsatisfied trait bound introduced here
help: consider restricting the type parameter to satisfy the trait bound
    |
172 |     L: LawsLike, P: PreferencesLike
    |                  ++++++++++++++++++

error[E0599]: the method `validate` exists for reference `&Scenario<D, L, P>`, but its trait bounds were not satisfied
   --> src/search/trap.rs:229:9
    |
229 |     scn.validate()?;
    |         ^^^^^^^^ method cannot be called on `&Scenario<D, L, P>` due to unsatisfied trait bounds
    |
note: trait bound `P: PreferencesLike` was not satisfied
   --> src/scenario/mod.rs:217:37
    |
217 | impl<D: DomainLike, L: LawsLike, P: PreferencesLike> Scenario<D, L, P> {
    |                                     ^^^^^^^^^^^^^^^  -----------------
    |                                     |
    |                                     unsatisfied trait bound introduced here
help: consider restricting the type parameter to satisfy the trait bound
    |
227 |     L: LawsLike, P: PreferencesLike
    |                  ++++++++++++++++++

warning: variable does not need to be mutable
  --> src/scenarios/nbb.rs:85:9
   |
85 |     let mut push_int = |x: i32, out: &mut Vec<State>, buf: &mut [i32; 8], buf_len: &mut usize| {
   |         ----^^^^^^^^
   |         |
   |         help: remove this `mut`
   |
   = note: `#[warn(unused_mut)]` (part of `#[warn(unused)]`) on by default

error[E0501]: cannot borrow `*tracker` as mutable because previous closure requires unique access
   --> src/search/trap.rs:362:77
    |
324 |               let mut try_add_b = |b: State,
    |  _________________________________-
325 | |                                  trap: &mut FxHashSet<State>,
326 | |                                  q: &mut VecDeque<State>|
327 | |              -> Result<(), SearchError> {
    | |_______________________________________- closure construction occurs here
...
335 |                       && is_stalemate_with_laws(scn, &scn.laws, &b, tracker)?
    |                                                                     ------- first borrow occurs due to use of `*tracker` in closure
...
362 |                           legal_white_moves(scn, &scn.laws, &scn.start.state, tracker)?;
    |                                                                               ^^^^^^^ second borrow occurs here
363 |                       for b in moves {
364 |                           try_add_b(b, &mut trap, &mut q)?;
    |                           --------- first borrow later used here

error[E0501]: cannot borrow `*tracker` as mutable because previous closure requires unique access
   --> src/search/trap.rs:370:17
    |
324 |               let mut try_add_b = |b: State,
    |  _________________________________-
325 | |                                  trap: &mut FxHashSet<State>,
326 | |                                  q: &mut VecDeque<State>|
327 | |              -> Result<(), SearchError> {
    | |_______________________________________- closure construction occurs here
...
335 |                       && is_stalemate_with_laws(scn, &scn.laws, &b, tracker)?
    |                                                                     ------- first borrow occurs due to use of `*tracker` in closure
...
370 |                   tracker.bump_steps("candidates_reachable_scan", 1)?;
    |                   ^^^^^^^ second borrow occurs here
...
376 |                           try_add_b(b2, &mut trap, &mut q)?;
    |                           --------- first borrow later used here

error[E0501]: cannot borrow `*tracker` as mutable because previous closure requires unique access
   --> src/search/trap.rs:372:73
    |
324 |               let mut try_add_b = |b: State,
    |  _________________________________-
325 | |                                  trap: &mut FxHashSet<State>,
326 | |                                  q: &mut VecDeque<State>|
327 | |              -> Result<(), SearchError> {
    | |_______________________________________- closure construction occurs here
...
335 |                       && is_stalemate_with_laws(scn, &scn.laws, &b, tracker)?
    |                                                                     ------- first borrow occurs due to use of `*tracker` in closure
...
372 |                   let after_black = legal_black_moves(scn, &scn.laws, &b, tracker)?;
    |                                                                           ^^^^^^^ second borrow occurs here
...
376 |                           try_add_b(b2, &mut trap, &mut q)?;
    |                           --------- first borrow later used here

error[E0501]: cannot borrow `*tracker` as mutable because previous closure requires unique access
   --> src/search/trap.rs:374:73
    |
324 |               let mut try_add_b = |b: State,
    |  _________________________________-
325 | |                                  trap: &mut FxHashSet<State>,
326 | |                                  q: &mut VecDeque<State>|
327 | |              -> Result<(), SearchError> {
    | |_______________________________________- closure construction occurs here
...
335 |                       && is_stalemate_with_laws(scn, &scn.laws, &b, tracker)?
    |                                                                     ------- first borrow occurs due to use of `*tracker` in closure
...
374 |                       let replies = legal_white_moves(scn, &scn.laws, &w, tracker)?;
    |                                                                           ^^^^^^^ second borrow occurs here
375 |                       for b2 in replies {
376 |                           try_add_b(b2, &mut trap, &mut q)?;
    |                           --------- first borrow later used here

Some errors have detailed explanations: E0501, E0599.
For more information about an error, try `rustc --explain E0501`.
warning: `infinite_chess` (lib) generated 1 warning
error: could not compile `infinite_chess` (lib) due to 6 previous errors; 1 warning emitted

Exit code 101
Edited file
mod.rs
+1
-2


impl<D: DomainLike, L: LawsLike, P: PreferencesLike> Scenario<D, L, P> {
impl<D: DomainLike, L: LawsLike, P> Scenario<D, L, P> {
    pub fn validate(&self) -> Result<(), SearchError> {
}

Explored 1 file
Edited file
trap.rs
+43
-37


            let mut try_add_b = |b: State,
                                 trap: &mut FxHashSet<State>,
                                 q: &mut VecDeque<State>|
             -> Result<(), SearchError> {
                if !scn.laws.allow_state(&b) {
                    return Ok(());
                }
                if !scn.domain.inside(&b) {
                    return Ok(());
                }
                if scn.remove_stalemates
                    && is_stalemate_with_laws(scn, &scn.laws, &b, tracker)?
                {
                    return Ok(());
                }

                if trap.insert(b.clone()) {
                    tracker.bump_states("candidates_reachable", 1)?;
                    if q.len() >= *max_queue {
                        return Err(SearchError::LimitExceeded {
                            stage: "candidates_reachable",
                            metric: "queue",
                            limit: *max_queue as u64,
                            observed: (q.len() + 1) as u64,
                            counts: tracker.counts(),
                        });
                    }
                    q.push_back(b);
                }
                Ok(())
            };

            match scn.start.to_move {
                Side::Black => {
                    try_add_b(scn.start.state.clone(), &mut trap, &mut q)?;
                    try_add_reachable_b(scn, tracker, *max_queue, &mut trap, &mut q, scn.start.state.clone())?;
                }
                Side::White => {
                    let moves =
                        legal_white_moves(scn, &scn.laws, &scn.start.state, tracker)?;
                    let moves = legal_white_moves(scn, &scn.laws, &scn.start.state, tracker)?;
                    for b in moves {
                        try_add_b(b, &mut trap, &mut q)?;
                        try_add_reachable_b(scn, tracker, *max_queue, &mut trap, &mut q, b)?;
                    }
                    for b2 in replies {
                        try_add_b(b2, &mut trap, &mut q)?;
                        try_add_reachable_b(scn, tracker, *max_queue, &mut trap, &mut q, b2)?;
                    }
}

fn try_add_reachable_b<D, L, P>(
    scn: &Scenario<D, L, P>,
    tracker: &mut ResourceTracker,
    max_queue: usize,
    trap: &mut FxHashSet<State>,
    q: &mut VecDeque<State>,
    b: State,
) -> Result<(), SearchError>
where
    D: DomainLike,
    L: LawsLike,
{
    if !scn.laws.allow_state(&b) {
        return Ok(());
    }
    if !scn.domain.inside(&b) {
        return Ok(());
    }
    if scn.remove_stalemates && is_stalemate_with_laws(scn, &scn.laws, &b, tracker)? {
        return Ok(());
    }

    if trap.insert(b.clone()) {
        tracker.bump_states("candidates_reachable", 1)?;
        if q.len() >= max_queue {
            return Err(SearchError::LimitExceeded {
                stage: "candidates_reachable",
                metric: "queue",
                limit: max_queue as u64,
                observed: (q.len() + 1) as u64,
                counts: tracker.counts(),
            });
        }
        q.push_back(b);
    }

    Ok(())
}
Edited file
nbb.rs
+1
-2


    let mut push_int = |x: i32, out: &mut Vec<State>, buf: &mut [i32; 8], buf_len: &mut usize| {
    let push_int = |x: i32, out: &mut Vec<State>, buf: &mut [i32; 8], buf_len: &mut usize| {
        buf[*buf_len] = x;
}

Ran command for 23s
$ cargo check

    Checking infinite_chess v0.1.0 (/home/hervay_bence_gmail_com/infinite_chess)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.29s
    Checking infinite_chess v0.1.0 (/home/hervay_bence_gmail_com/infinite_chess)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.29s

Success
Ran command for 19s
$ cargo fmt

No output

Success
Ran command for 17s
$ cargo test

   Compiling infinite_chess v0.1.0 (/home/hervay_bence_gmail_com/infinite_chess)
error[E0308]: mismatched types
  --> tests/laws.rs:77:11
   |
77 |         ..scn_allow
   |           ^^^^^^^^^ expected `Scenario<AllDomain, NoCapturesLaws, _>`, found `Scenario<AllDomain, NoLaws, ...>`
   |
   = note: expected struct `Scenario<_, NoCapturesLaws, _>`
              found struct `Scenario<_, NoLaws, NoPreferences>`

For more information about this error, try `rustc --explain E0308`.
error: could not compile `infinite_chess` (test "laws") due to 1 previous error
warning: build failed, waiting for other jobs to finish...
   Compiling infinite_chess v0.1.0 (/home/hervay_bence_gmail_com/infinite_chess)
error[E0308]: mismatched types
  --> tests/laws.rs:77:11
   |
77 |         ..scn_allow
   |           ^^^^^^^^^ expected `Scenario<AllDomain, NoCapturesLaws, _>`, found `Scenario<AllDomain, NoLaws, ...>`
   |
   = note: expected struct `Scenario<_, NoCapturesLaws, _>`
              found struct `Scenario<_, NoLaws, NoPreferences>`

For more information about this error, try `rustc --explain E0308`.
error: could not compile `infinite_chess` (test "laws") due to 1 previous error
warning: build failed, waiting for other jobs to finish...

Exit code 101
Edited file
laws.rs
+11
-1

    let scn_forbid = Scenario {
        name: "forbid_capture",
        rules: scn_allow.rules.clone(),
        white_can_pass: scn_allow.white_can_pass,
        track_abs_king: scn_allow.track_abs_king,
        start: scn_allow.start.clone(),
        candidates: scn_allow.candidates.clone(),
        domain: scn_allow.domain,
        laws: NoCapturesLaws,
        ..scn_allow
        preferences: NoPreferences,
        limits: scn_allow.limits,
        cache_mode: scn_allow.cache_mode,
        remove_stalemates: scn_allow.remove_stalemates,
    };
Ran command for 11s
$ cargo test


running 1 test
test chess::layout::tests::runs_group_identical_pieces ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s


running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s


running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s


running 2 tests
test leaving_domain_is_escape_if_white_cannot_return ... ok
test leaving_domain_is_allowed_if_white_can_return_immediately ... ok

test result: ok. 2 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s


running 4 tests
test three_rooks_has_48_checkmates_in_linf_bound2 ... ok
test two_rooks_has_no_checkmate_even_in_linf_bound7 ... ok
test inescapable_trap_size_for_three_rooks_bound2_mb1_is_169 ... ok
test tempo_trap_size_for_three_rooks_bound2_mb1_is_113_and_excludes_mates ... ok

test result: ok. 4 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.13s


running 2 tests
test law_can_forbid_black_capture ... ok
test pass_can_be_controlled_by_law_predicate ... ok

test result: ok. 2 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s


running 1 test
test mate_logic_does_not_treat_enumeration_bound_as_a_wall ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s


running 1 test
test nbb20_from_file_has_nonempty_trap_sets ... ignored

test result: ok. 0 passed; 0 failed; 1 ignored; 0 measured; 0 filtered out; finished in 0.00s


running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

   Compiling infinite_chess v0.1.0 (/home/hervay_bence_gmail_com/infinite_chess)
    Finished `test` profile [unoptimized + debuginfo] target(s) in 1.23s
     Running unittests src/lib.rs (target/debug/deps/infinite_chess-b655c8f13bd26b52)
     Running unittests src/bin/mate_search.rs (target/debug/deps/mate_search-2bc17d3c93e02a53)
     Running unittests src/bin/trap_search.rs (target/debug/deps/trap_search-04eabddace9317fb)
     Running tests/domain_semantics.rs (target/debug/deps/domain_semantics-ec587b85f6d49435)
     Running tests/known_results.rs (target/debug/deps/known_results-c288e43f1c91bd73)
     Running tests/laws.rs (target/debug/deps/laws-d16ad09451fa8e64)
     Running tests/mate_nonwall.rs (target/debug/deps/mate_nonwall-acbbc104a8652fc0)
     Running tests/nbb20.rs (target/debug/deps/nbb20-0e30286d95b74af5)
   Doc-tests infinite_chess
   Compiling infinite_chess v0.1.0 (/home/hervay_bence_gmail_com/infinite_chess)
    Finished `test` profile [unoptimized + debuginfo] target(s) in 1.23s
     Running unittests src/lib.rs (target/debug/deps/infinite_chess-b655c8f13bd26b52)

running 1 test
test chess::layout::tests::runs_group_identical_pieces ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

     Running unittests src/bin/mate_search.rs (target/debug/deps/mate_search-2bc17d3c93e02a53)

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

     Running unittests src/bin/trap_search.rs (target/debug/deps/trap_search-04eabddace9317fb)

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

     Running tests/domain_semantics.rs (target/debug/deps/domain_semantics-ec587b85f6d49435)

running 2 tests
test leaving_domain_is_escape_if_white_cannot_return ... ok
test leaving_domain_is_allowed_if_white_can_return_immediately ... ok

test result: ok. 2 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

     Running tests/known_results.rs (target/debug/deps/known_results-c288e43f1c91bd73)

running 4 tests
test three_rooks_has_48_checkmates_in_linf_bound2 ... ok
test two_rooks_has_no_checkmate_even_in_linf_bound7 ... ok
test inescapable_trap_size_for_three_rooks_bound2_mb1_is_169 ... ok
test tempo_trap_size_for_three_rooks_bound2_mb1_is_113_and_excludes_mates ... ok

test result: ok. 4 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.13s

     Running tests/laws.rs (target/debug/deps/laws-d16ad09451fa8e64)

running 2 tests
test law_can_forbid_black_capture ... ok
test pass_can_be_controlled_by_law_predicate ... ok

test result: ok. 2 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

     Running tests/mate_nonwall.rs (target/debug/deps/mate_nonwall-acbbc104a8652fc0)

running 1 test
     Running tests/nbb20.rs (target/debug/deps/nbb20-0e30286d95b74af5)
test mate_logic_does_not_treat_enumeration_bound_as_a_wall ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

   Doc-tests infinite_chess

running 1 test
test nbb20_from_file_has_nonempty_trap_sets ... ignored

test result: ok. 0 passed; 0 failed; 1 ignored; 0 measured; 0 filtered out; finished in 0.00s


running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s


Success
Ran command for 1s
$ cargo run --quiet --bin trap_search -- three_rooks_bound2_mb1

Scenario: three_rooks_bound2_mb1
  pieces: [Rook, Rook, Rook]
  move_bound: 1
  white_can_pass: true
  remove_stalemates: true
  candidates: InLinfBound { bound: 2, allow_captures: true }
  track_abs_king: false
  cache_mode: BothBounded
  limits:
    max_states: 1000000
    max_edges: 25000000
    max_cache_entries: 100000
    max_cached_moves: 5000000
    max_runtime_steps: 50000000
inescapable trap size: 169
tempo trap size: 113
Scenario: three_rooks_bound2_mb1
  pieces: [Rook, Rook, Rook]
  move_bound: 1
  white_can_pass: true
  remove_stalemates: true
  candidates: InLinfBound { bound: 2, allow_captures: true }
  track_abs_king: false
  cache_mode: BothBounded
  limits:
    max_states: 1000000
    max_edges: 25000000
    max_cache_entries: 100000
    max_cached_moves: 5000000
    max_runtime_steps: 50000000
inescapable trap size: 169
tempo trap size: 113

Success
Ran command for 17s
$ cargo run --quiet --bin mate_search -- three_rooks_bound2_mb1

Scenario: three_rooks_bound2_mb1
  pieces: [Rook, Rook, Rook]
  bound: 2
  checkmates in slice (infinite-board legality): 48
Scenario: three_rooks_bound2_mb1
  pieces: [Rook, Rook, Rook]
  bound: 2
  checkmates in slice (infinite-board legality): 48

Success
Implemented the full scenario layering + budgets refactor.

New scenario API + types in mod.rs (line 1) (replaces chess::config::ScenarioConfig, which is deleted).
Laws-aware movegen + mate/stalemate helpers in movegen.rs (line 1).
Budget tracking + allocation guards in resources.rs (line 1).
Trap + tempo-trap solvers refactored to State + Laws/Domain + Result<_, SearchError> in trap.rs (line 1) and buchi.rs (line 1).
Built-in scenarios updated + added nbb20_from_file loader in mod.rs (line 1) and nbb.rs (line 1); CLIs updated in trap_search.rs (line 1) and mate_search.rs (line 1).
Added tests for laws/domain semantics/mate non-wall + ignored NBB test in laws.rs (line 1), domain_semantics.rs (line 1), mate_nonwall.rs (line 1), nbb20.rs (line 1).
Run: cargo test, cargo run --bin trap_search -- three_rooks_bound2_mb1. For the heavy NBB check: cargo test --release -- --ignored nbb20_from_file_has_nonempty_trap_sets.


20 files changed
+1706
-285
Undo

Review
src/bin/mate_search.rs
src/bin/trap_search.rs
src/chess/config.rs
src/chess/mod.rs
src/chess/rules.rs
src/lib.rs
src/scenario/mod.rs
src/scenarios/mod.rs
src/scenarios/nbb.rs
src/search/buchi.rs
src/search/mod.rs
src/search/movegen.rs
src/search/resources.rs
src/search/strategy.rs
src/search/trap.rs
tests/domain_semantics.rs
tests/known_results.rs
tests/laws.rs
tests/mate_nonwall.rs
tests/nbb20.rs





GPT-5.2
Extra High



Local
